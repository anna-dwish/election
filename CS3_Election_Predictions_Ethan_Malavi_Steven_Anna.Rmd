---
title: "Case Study 3: Election Predictions"
author: "Ethan Shen, Malavi Ravindran, Steven Herrera Tenorio, Anna Darwish"
geometry: "left=1.25cm,right=1.25cm,top=1.3cm,bottom=1.3cm"
fontsize: 12pt
output: 
  pdf_document:
     number_sections: true
---

```{r, function checking for installed packages, include=FALSE}
# Validate that all necessary packaged have been downloaded, install otherwise or throw err package DNE
pkgTest <- function(x)
{
  if (!require(x,character.only = TRUE))
  {
    install.packages(x,repos = "http://cran.r-project.org", dep=TRUE)
    if(!require(x,character.only = TRUE)) stop("Package not found")
  }
}
```

```{r package test, include=FALSE}
# Installing packages 
# Additionally, if you are struggling to download RJags, please visit the following link for help. It can also help to try to download the package locally or in RStudio Cloud: https://sites.google.com/a/utexas.edu/edm-principalstratification/downloading-installing-r-jags-rstudio
pkgTest("ggplot2")
pkgTest("lubridate")
pkgTest("R2jags")
pkgTest("tidyverse")
pkgTest("coda")
pkgTest("kableExtra")
pkgTest("matrixStats")
```

```{r load packages, include=FALSE, results="hide"}
library(ggplot2)
library(lubridate)
library(R2jags)
library(tidyverse)
library(coda)
library(kableExtra)
library(matrixStats)
```

```{r include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE)
ggplot2::theme_set(theme_bw())
```

```{r Read in Presidential Polls Data}
president_polls <- read_csv("2020 US presidential election polls - all_polls.csv") %>% 
  filter(population %in% c("lv","rv")) %>% 
  mutate(state = ifelse(state == "--","US",state)) %>%
  mutate(pct = biden / (biden + trump) *100) 

#colnames(president_polls)

president_polls <- president_polls %>% 
  mutate(start.date = mdy(start.date),
         end.date = mdy(end.date),
         election_date = "2020-11-03" %>% as.Date(),
         days_to_election = election_date - end.date)

president_polls <- president_polls[president_polls$start.date >= "2020-06-01",]

president_polls <- president_polls %>%
  filter(state %in% c("AZ", "CO", "FL", "GA", "IA", "ME", "MI", "NC", "OH", "PA", "TX", "WI", "MN", "NV", "NH"))

#got rid of US: why? covariance matrix will be hard to estimate
#swing states are: Arizona, Colorado, Florida, Georgia, Iowa, Maine, Michigan, North Carolina, Ohio, Pennsylvania, Texas, Wisconsin, Minnesota, Nevada, New Hampshire
#these were determined from the following map and external sources: https://www.270towin.com/. 
#should we get rid of "US"? The popular vote doesn't really matter anyways. 
```

```{r include=FALSE}
#which states are not represented at all in polling data? none are swing, so we're good
# State_Abbrev <- c("AL", "AK","AZ","AR","CA","CO","CT","DC",
#                   "DE","FL","GA","HI","ID","IL","IN","IA","KS",
#                   "KY","LA","ME","MD","MA","MI","MN","MS","MO","MT",
#                   "NE","NV","NH","NJ","NM","NY","NC","ND","OH","OK",
#                   "OR","PA","RI","SC","SD","TN","TX","UT","VT","VA","WA","WV","WI","WY")

```

```{r include=FALSE}
# swing <- c("AZ", "CO", "FL", "GA", "IA", "ME", "MI", "NC", "OH", "PA", "TX", "WI", "MN", "NV", "NH")
# State_Abbrev[!(State_Abbrev %in% swing)]
```

```{r votes going to Biden}
#going to biden:
biden <- c(55, 7, 3, 3, 4, 20, 10, 11, 14, 5, 29, 7, 4, 3, 13, 12)
dem_states <- c("CA", "CT", "DC", "DE", "HI", "IL", "MD", "MA", "NJ", "NM", "NY", "OR", "RI", "VT", "VA", "WA")
votes_going_to_biden <- sum(biden)
#votes_going_to_biden
```

```{r presidential data_list}
states <- president_polls$state %>% unique
y <- president_polls$pct
r <- match(president_polls$state,states)
t <- president_polls$days_to_election + 1 
N_polls <- y %>% length
N_states <- states %>% length
N_days <- t %>% max
I_states <- diag(N_states)
```

```{r clinton vote share priors}
#"AZ", "CO", "FL", "GA", "IA", "ME", "MI","MN","NC", "NV", "NH", "OH", "PA", "TX", "WI"
vote_share_2016 <- data.frame(president_polls$state, number = r)
vote_share_2016 <- unique(vote_share_2016) %>%
  mutate(clinton_percent = case_when(
    president_polls.state == "AZ" ~ 45/(48 + 45),
    president_polls.state == "CO" ~ 47/(47 + 44),
    president_polls.state == "FL" ~ 48/(48 + 49),
    president_polls.state == "GA" ~ 46/(46 + 51),
    president_polls.state == "IA" ~ 42/(42 + 52),
    president_polls.state == "ME" ~ 48/(48 + 45),
    president_polls.state == "MI" ~ 47/(47 + 48),
    president_polls.state == "MN" ~ 47/(47 + 45),
    president_polls.state == "NC" ~ 47/(47 + 51),
    president_polls.state == "NH" ~ 48/(48 + 47),
    president_polls.state == "NV" ~ 48/(48 + 46),
    president_polls.state == "OH" ~ 44/(44 + 52),
    president_polls.state == "PA" ~ 48/(48 + 49),
    president_polls.state == "TX" ~ 43/(43 + 53),    
    president_polls.state == "WI" ~ 47/(47 + 48)
    
    
    
    
    
    
  )) %>%
  mutate(clinton_percent = 100*clinton_percent)
h <- vote_share_2016$clinton_percent
```

```{r}
generate_presidential_model_text = function(hierarchical_priors) {
  model_file <- tempfile()
  likelihood_base_priors = "
  for(k in 1:N_polls){
    y[k] ~ dnorm(p[k],1/sigma2_y[r[k]]) #note no longer binomial
    p[k] = theta[r[k],t[k]] 
  }
  for(j in 2:N_days){
    theta[1:N_states,j] ~ dmnorm(theta[1:N_states,j-1], Phi)
  }
  
  Phi ~ dwish(I_states,N_states+1) 
  Sigma = inverse(Phi)
  
  #hierarchical component
  for(i in 1:N_states){
    sigma2_y[i] = 1/sigma2_y_inv[i]
    sigma2_y_inv[i] ~ dgamma(nu_y,nu_y*tau_y) 
    
    theta[i,1] ~ dnorm(h[i], sigma2_0)
  }
  "
  
  model_text <- paste("model{ ", likelihood_base_priors, hierarchical_priors,"}")
  writeLines(model_text,con=model_file)
  return(model_file)
}
```


```{r final presidential model}
# final model 
gamma_2_0.5_prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  nu_beta ~ dunif(0,100)
  tau_beta ~ dunif(0,100)
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(2, 0.5)
  "

model_file <- generate_presidential_model_text(gamma_2_0.5_prior)
if (file.exists("gamma_2_0.5.Rds")) {
  presidential_model_gamma_2_0.5_prior <- readRDS("gamma_2_0.5.Rds")
} else {
  presidential_model_gamma_2_0.5_prior <- jags(data = list("y","t", "r", "N_polls", 
                                                           "N_states", "N_days", "h", "I_states"),  
                                               parameters.to.save = c("theta", "Sigma", 
                                                                      "p","sigma2_y", "sigma2_0"),
                                               n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                               model.file = model_file)
  
  saveRDS(presidential_model_gamma_2_0.5_prior, file = "gamma_2_0.5.Rds")
}
```

```{r final presidential model electoral votes function}
iterations = presidential_model_gamma_2_0.5_prior$BUGSoutput$n.keep * presidential_model_gamma_2_0.5_prior$BUGSoutput$n.chains 

electoral_data <- read.csv("Electoral_College.csv") %>%
  filter(Year == 2020)

electoral_data$states <- c("AL", "AK","AZ","AR","CA","CO","CT","DC",
                           "DE","FL","GA","HI","ID","IL","IN","IA","KS",
                           "KY","LA","ME","MD","MA","MI","MN","MS","MO","MT",
                           "NE","NV","NH","NJ","NM","NY","NC","ND","OH","OK",
                           "OR","PA","RI","SC","SD","TN","TX","UT","VT","VA","WA","WV","WI","WY")

#returns number of electoral votes biden wins for each iteration of the sampler
#we need to add to this the votes that he is guaranteed from other states

prediction_per_simulation <- function(model_output, i){
  elec_sims <- model_output$BUGSoutput$sims.list$theta[i,,1]
  vote_share_by_state <- data.frame(states, elec_sims)
  
  
  results <- merge(vote_share_by_state, electoral_data, by = "states") %>%
    dplyr::select(-c(Year)) 
  biden_wins <- results %>%
    filter(elec_sims > 50) 
  biden_electoral_votes <- sum(biden_wins$Votes)
  
  #add in the number of guaranteed votes from other states!
  biden_votes = votes_going_to_biden + biden_electoral_votes
  return(biden_votes)
}
```


```{r eval=FALSE}
i = 1
model_output = presidential_model_gamma_2_0.5_prior
yes = list()
for (k in 1:2000) {
  elec_sims <- model_output$BUGSoutput$sims.list$theta[k,,1]
  vote_for_biden = list()
  for (i in 1:length(elec_sims)) {
    list = c()
    for (j  in  1:100) {
      list[j] <- rbinom(100, 1, elec_sims[i]/100) %>% mean()
    }
    vote_for_biden[[i]] <- list
  }
  yes[[k]] <- vote_for_biden
  
  if (k %% 50 == 0) {
    print(k)
  }
}
yes %>% unlist() %>% sd()
```


```{r final presidential model electoral votes histogram}
final_results_presidential <- c()

for (i in 1:iterations){
  final_results_presidential[i] = prediction_per_simulation(presidential_model_gamma_2_0.5_prior, i)
}


#hist(final_results, main = "Presidential Election: Predicted Number of Electoral Votes to Biden", xlab = "Count")

prob_of_biden_winning <- mean(final_results_presidential > 270) * 100
lower_q_prob_of_biden_winning  <- quantile(final_results_presidential > 270, probs = c(0.025))
upper_q_prob_of_biden_winning  <-  quantile(final_results_presidential > 270, probs = c(0.975))
mean_electoral <- mean(final_results_presidential)
lower_q_presidential_electoral_college <- quantile(final_results_presidential, probs = c(0.025))
upper_q_presidential_electoral_college <- quantile(final_results_presidential, probs = c(0.975))


presidential_results_plot <- ggplot(data = tibble(final_results_presidential),  aes(x = final_results_presidential)) + 
  geom_histogram(bins = 20, colour="black",fill = "#4d4d4d") + 
  geom_vline(xintercept = 270, color = "#1b7837", size = 1.1) + 
  geom_vline(xintercept = mean_electoral, color = "#542788", size = 1.1) + 
  geom_vline(xintercept = c(lower_q_presidential_electoral_college,upper_q_presidential_electoral_college), color = "#542788", linetype = 2, size = 0.7) + 
  labs(title = "Predicted Number of Biden's Electoral Votes",
       subtitle = paste0("Predicted Probability of Biden Winning: ", prob_of_biden_winning, "%"),
       x = "Number of Biden's Electoral Votes",
       y = "Count")
```

```{r Probability of Democratic Victory in each Swing State, cache=TRUE}
predictions_per_state_presidential <- function(model_output, state){
  win_dem <- c()
  for (i in 1:iterations){
    
    elec_sims <- model_output$BUGSoutput$sims.list$theta[i,,1]
    vote_share_for_state <- data.frame(states, elec_sims) %>%
      filter(states == state)
    vote_share_val <- vote_share_for_state$elec_sims
    if (vote_share_val > 50){
      win_dem[i] <- 1
    }
    if (vote_share_val < 50){
      win_dem[i] <- 0
    }
  }
  probability_voting_dem <- round(100*sum(win_dem)/iterations, 3)
  return(probability_voting_dem)
}

probs_voting_dem <- c()
i = 1
for (state in states){
  prob_voting_dem <- predictions_per_state_presidential(presidential_model_gamma_2_0.5_prior, state)
  probs_voting_dem[i] <- prob_voting_dem
  i = i + 1
}

prob_voting_dem_table <- data.frame(states, probs_voting_dem) %>%
  mutate(State = states) %>%
  mutate(Probability = probs_voting_dem/100) %>%
  select(State, Probability)
kable(prob_voting_dem_table, caption = "Presidential Election: Probability of Democratic Victory in each Swing State")

```

```{r Predicted Democratic Vote Share in each Swing State}
mean_vote_share <- presidential_model_gamma_2_0.5_prior$BUGSoutput$sims.list$theta[,,1] %>% colMeans()
lower_q_presidential <- presidential_model_gamma_2_0.5_prior$BUGSoutput$sims.list$theta[,,1] %>%  matrixStats::colQuantiles(probs = c(0.025))
upper_q_presidential <- presidential_model_gamma_2_0.5_prior$BUGSoutput$sims.list$theta[,,1] %>%  matrixStats::colQuantiles(probs = c(0.975))

vote_share_by_state <- data.frame(states, lower_q_presidential, mean_vote_share, upper_q_presidential) %>%
  mutate(State = states) %>%
  mutate(`2.5%` = round(lower_q_presidential, 1)) %>%
  mutate(`97.5%` = round(upper_q_presidential, 1)) %>%
  mutate(Mean = round(mean_vote_share, 1)) %>%
  select(State, `2.5%`, Mean, `97.5%`)
kable(vote_share_by_state, caption = "Presidential Elections: Predicted Democratic Vote Share in each Swing State")
```

```{r}

# ggplot() + 
#   geom_density(aes(x = presidential_model_gamma_2_0.5_prior$BUGSoutput$sims.list$theta[,1,1])) + 
#   geom_vline(xintercept = theta_1_1_mean)

# tidybayes::gather_draws(presidential_model_gamma_2_0.5_prior %>% as.mcmc() %>% mcmc.list() , theta[i, j]) %>% 
#   filter(i == 1 & j == 1) %>% 
#   mutate(param = ifelse(is.na(i), .variable, paste0(.variable,"[", i,", ", j, "]"))) %>%
#   ggplot(aes(x = .iteration, y = .value, color = as.factor(.chain))) + 
#   geom_line(alpha = 0.6) +  
#   facet_grid(param~., scales = "free_y")
```

```{r presidential model sensitivity 1}
gamma_4_1_prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  nu_beta ~ dunif(0,100)
  tau_beta ~ dunif(0,100)
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(4, 1)
  "

model_file <- generate_presidential_model_text(gamma_4_1_prior)
if (file.exists("gamma_4_1.Rds")) {
  presidential_model_gamma_4_1_prior <- readRDS("gamma_4_1.Rds")
} else {
  presidential_model_gamma_4_1_prior <- jags(data = list("y","t", "r", "N_polls", 
                                                         "N_states", "N_days", "h", "I_states"),  
                                             parameters.to.save = c("theta", "Sigma", 
                                                                    "p","sigma2_y", "sigma2_0"),
                                             n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                             model.file = model_file)
  
  saveRDS(presidential_model_gamma_4_1_prior, file = "gamma_4_1.Rds")
}
```

```{r}
# final_results <- c()
# 
# for (i in 1:iterations){
#   final_results[i] = prediction_per_simulation(presidential_model_gamma_4_1_prior, i)
# }
# 
# hist(final_results)
# mean(final_results >= 270)
# 
# ggplot() + 
#   geom_density(aes(x = presidential_model_gamma_4_1_prior$BUGSoutput$sims.list$theta[,1,1])) + 
#   geom_vline(xintercept = theta_1_1_mean)
# 
# tidybayes::gather_draws(presidential_model_gamma_4_1_prior %>% coda::as.mcmc(), theta[i, j]) %>% 
#   filter(i == 1 & j == 1) %>% 
#   mutate(param = ifelse(is.na(i), .variable, paste0(.variable,"[", i,", ", j, "]"))) %>%
#   ggplot(aes(x = .iteration, y = .value, color = as.factor(.chain))) + 
#   geom_line(alpha = 0.6) +  
#   facet_grid(param~., scales = "free_y")

```

```{r presidential model sensitivity 2}
exp_0.25_prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  nu_beta ~ dunif(0,100)
  tau_beta ~ dunif(0,100)
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dexp(0.25)
  "

model_file <- generate_presidential_model_text(exp_0.25_prior)
if (file.exists("exp_0_25.Rds")) {
  presidential_model_exp_0.25_prior <- readRDS("exp_0_25.Rds")
} else {
  presidential_model_exp_0.25_prior <- jags(data = list("y","t", "r", "N_polls", 
                                                        "N_states", "N_days", "h", "I_states"),  
                                            parameters.to.save = c("theta", "Sigma", 
                                                                   "p","sigma2_y", "sigma2_0"),
                                            n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                            model.file = model_file)
  
  saveRDS(presidential_model_exp_0.25_prior, file = "exp_0_25.Rds")
}
```

```{r}
# final_results <- c()
# 
# for (i in 1:iterations){
#   final_results[i] = prediction_per_simulation(presidential_model_exp_0.25_prior, i)
# }
# 
# hist(final_results)
# mean(final_results >= 270)
# 
# 
# ggplot() + 
#   geom_density(aes(x = presidential_model_exp_0.25_prior$BUGSoutput$sims.list$theta[,1,1])) + 
#   geom_vline(xintercept = theta_1_1_mean)

# tidybayes::gather_draws(presidential_model_exp_0.25_prior %>% coda::as.mcmc(), theta[i, j]) %>% 
#   filter(i == 1 & j == 1) %>% 
#   mutate(param = ifelse(is.na(i), .variable, paste0(.variable,"[", i,", ", j, "]"))) %>%
#   ggplot(aes(x = .iteration, y = .value, color = as.factor(.chain))) + 
#   geom_line(alpha = 0.6) +  
#   facet_grid(param~., scales = "free_y")

```

```{r presidential model sensitivity 3}
gamma_1_0.25_prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  nu_beta ~ dunif(0,100)
  tau_beta ~ dunif(0,100)
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(1, 0.25)
  "

model_file <- generate_presidential_model_text(gamma_1_0.25_prior)
if (file.exists("gamma_1_025.Rds")) {
  presidential_model_gamma_1_0.25_prior <- readRDS("gamma_1_025.Rds")
} else {
  presidential_model_gamma_1_0.25_prior <- jags(data = list("y","t", "r", "N_polls", 
                                                            "N_states", "N_days", "h", "I_states"),  
                                                parameters.to.save = c("theta", "Sigma", 
                                                                       "p","sigma2_y", "sigma2_0"),
                                                n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                                model.file = model_file)
  
  saveRDS(presidential_model_gamma_1_0.25_prior, file = "gamma_1_025.Rds")
}
```

```{r}
# final_results <- c()
# 
# for (i in 1:iterations){
#   final_results[i] = prediction_per_simulation(presidential_model_gamma_1_0.25_prior, i)
# }
# 
# hist(final_results)
# mean(final_results >= 270)
# 
# 
# ggplot() + 
#   geom_density(aes(x = presidential_model_gamma_1_0.25_prior$BUGSoutput$sims.list$theta[,1,1])) + 
#   geom_vline(xintercept = theta_1_1_mean)

# tidybayes::gather_draws(presidential_model_gamma_1_0.25_prior %>% coda::as.mcmc(), theta[i, j]) %>% 
#   filter(i == 1 & j == 1) %>% 
#   mutate(param = ifelse(is.na(i), .variable, paste0(.variable,"[", i,", ", j, "]"))) %>%
#   ggplot(aes(x = .iteration, y = .value, color = as.factor(.chain))) + 
#   geom_line(alpha = 0.6) +  
#   facet_grid(param~., scales = "free_y")
```

```{r presidential model sensitivity plots, cache=TRUE}
sen_analysis_priors_names <- c("Ga(2, 0.5))",
                               "Ga(4, 1)",
                               "Ga(1, 0.25)",
                               "Exp(1/4)")   
sen_analysis_priors <- list(presidential_model_gamma_2_0.5_prior,
                            presidential_model_gamma_4_1_prior,
                            presidential_model_exp_0.25_prior,
                            presidential_model_gamma_1_0.25_prior)     



sen_tbl_list <- list()
for (i in 1:4) {
  final_results_presidential_sensitivity <- c()
  for (sim in 1:iterations) {
    
    final_results_presidential_sensitivity[sim] = prediction_per_simulation(sen_analysis_priors[[i]], sim)
  }
  sen_tbl_list[[i]] <- as_tibble(final_results_presidential_sensitivity)
}

theta_1_1_mean <- presidential_model_gamma_2_0.5_prior$BUGSoutput$sims.list$theta[,5,1] %>% mean()

sensitivity_plot_presidential <- do.call(bind_rows, sen_tbl_list) %>% 
  dplyr::mutate(model = rep(sen_analysis_priors_names, each=2000),
                model = factor(model,
                               levels = sen_analysis_priors_names,
                               labels = c(expression(paste("1/", sigma[0]^2, " ~ Ga(2, 0.5)")),
                                          expression(paste("1/", sigma[0]^2, " ~ Ga(4, 1)")),
                                          expression(paste("1/", sigma[0]^2, " ~ Ga(1, 0.25)")),
                                          expression(paste("1/", sigma[0]^2, " ~ Exp(0.25)"))))) %>% 
  ggplot() + 
  geom_density(aes(x = value)) + 
  #geom_histogram(aes(x = value), bins = 18) + 
  geom_vline(xintercept = mean_electoral, color = "#542788") + 
  geom_vline(xintercept = c(lower_q_presidential_electoral_college,upper_q_presidential_electoral_college), color = "#542788", linetype = 2) + 
  facet_wrap(model~., labeller = "label_parsed") + 
  labs(title = "Sensitivity Analysis",
       subtitle = "Predicted Number of Biden's Electoral Votes",
       x = "Number of Biden's Electoral Votes",
       y = "Density")
```

# Introduction

In the wake of the social and economic turmoil from the COVID-19 pandemic, the 2020 U.S. elections are expected to have far-reaching political implications [[1]][Bibliography][[2]][Bibliography]. Predicting the results of these elections is of critical interest to small businesses, health professionals, racial minorities, and many others. Our specific research objectives include the following:

1. Predict the outcome of the presidential election and the Electoral College vote
2. Predict whether the U.S. Senate remains in Republican control and the outcome of the North Carolina Senate election
3. Predict the outcomes of all 13 North Carolina Congressional elections 

We seek to provide not only predictions of winners and estimated vote shares, but also meaningful quantifications of uncertainty surrounding our estimates. We use a variant of the Linzer model [[3]][Bibliography] to predict the presidential and senate outcomes. To estimate the outcomes of the 13 North Carolina Congressional elections, we first explore voting patterns of different demographics within the state to determine who is likely to vote. We then utilize a multilevel logistic regression model to predict *how* these individuals will vote in their respective district. This analysis can offer insight to campaign managers and activist groups so they may better understand voting patterns in North Carolina.

# Presidential Election

## Data

We utilize state-wide presidential election polls from 2020 to predict the outcome of the presidential election and the electoral college vote. Each sample in the dataset includes the start date of the poll, the percentages of people who would vote for Biden or Trump, and whether the sampled population were “likely” voters, registered voters, or simply adults. We only keep polls that sample populations of registered and likely voters, and we filter the polls to only include those after June 1st, which is right before Biden secured the Democratic candidate nomination [[6]][Bibliography]. For each poll, we calculate Biden’s share of the two-party vote by dividing Biden’s percentage by the sum of Trump’s and Biden’s percentages.

## Methods

We employ a dynamic Bayesian approach to forecast presidential election outcomes, similar to that of Linzer [[3]][Bibliography]. Our motivation in selecting this model stems from its ability to compound polling data *over time*. Rather than using a naive model that is heavily influenced by an inaccurate poll, this model accounts for several polls with evolving preferences. While the Linzer model incorrectly predicted the results of the 2016 presidential election due to polling information inaccuracies, we balance this reliance on the polling information by adjusting our priors to rely on the 2016 election [[5]][Bibliography]. With this data, we predict the outcomes of 15 swing states, which hold a total of 212 electoral votes: Arizona, Colorado, Florida, Georgia, Iowa, Maine, Michigan, Minnesota, New Hampshire, Nevada, North Carolina, Ohio, Pennsylvania, Texas, and Wisconsin [[4]][Bibliography]. 

$$
\begin{aligned}
Y_{k} \sim  N(\theta_{i[k]t[k]},\sigma^2_{yi}) \\ 
\theta_{i 1} \sim N(h_i, \sigma^2_0) , \ \mathbf{\theta_{\mathbf{ \cdot} t}} \sim MVN&(\mathbf{\theta_{\mathbf{\cdot} t-1}},\mathbf{\Sigma}) \\ 
\mathbf{\Sigma}^{-1} \sim Wish(\mathbf{I_{15}}, 16&) &  (1) \\
\frac{1}{\sigma^2_{yi}} \sim Ga(\nu_y,\nu_y*\tau_y) , \ \frac{1}{\sigma^2_{0}} \sim & \ Ga(2, 0.5)\\
\nu_y \sim Unif(0,100), \ \tau_y \sim Un&if(0,100)\\
\end{aligned}
$$

(1) represents the final model we use to predict the presidential election. Let $Y_k$, Biden's share of the two-party vote from each poll $k$, be normally distributed with mean $\theta_{i[k]t[k]}$, where poll $k$ ended $t$ days before the election and was conducted in swing state $i \in (1 \dots 15)$. Each state $i$ has its own observation variance, $\sigma^2_{yi}$, where the indice $y$ indicates that it is the observation variance from each state. We set a Gamma prior on $\frac{1}{\sigma^2_{yi}}\sim Ga(\nu_y,\nu_y*\tau_y)$, where both $\nu_y, \tau_y \sim Unif(0,100)$. We set normal priors on $\boldsymbol{\theta}_{\boldsymbol{ \cdot}  1}$, centered on $h_i$, Clinton’s vote share from swing state $i$ in 2016, with variance $\sigma^2_0$. We also estimate the correlation structure between states, where $\boldsymbol{\theta}_{\boldsymbol{ \cdot} t} \sim MVN(\boldsymbol{\theta}_{\boldsymbol{\cdot} t-1},\mathbf{\Sigma})$, where $\mathbf{\Sigma}^{-1} \sim Wish(\mathbf{I_{15}}, 16)$, so more similar states can pull information from one another.

Using JAGS, we run (1) with 2 chains, each with 75,000 simulations, 25,000 burn-in, and thinned the sampler by keeping every 50th sample. This leaves us with 2,000 samples. Then, for each sample, we perform the following:

1. Extract the 15 values of  $\theta_{\cdot 1}$, Biden’s estimated vote share on the day of the election from swing state $i \in (1 \dots 15)$.

2. If $\theta_{i 1}$ > 50%, the model predicts Biden will win the electoral votes from swing state $i$. Then sum the total number of predicted electoral votes Biden will gain from swing states.

3. Add 200 to the previous sum, as Biden is expected to safely win 200 electoral votes from 16 states [SOURCE]. Biden is predicted to win the election if this value is greater than 270.

We iterate this process for each of the 2,000 samples to predict the electoral college vote and the outcome of the presidential election.

## Results

```{r fig.align="center"}
presidential_results_plot + labs(caption = "Figure 1") +
  theme(plot.caption = element_text(hjust = 0.5, vjust = -0.5))
```

Figure 1 displays the posterior predictions for Biden's number of electoral votes. The green line is drawn at 270 and the solid and dashed purple lines indicate the mean and 95% credible interval, respectively. The posterior predictions indicate that Biden will win an average of `r mean_electoral` electoral college votes, with a 95% credible interval of (`r lower_q_presidential_electoral_college`, `r upper_q_presidential_electoral_college`). In `r prob_of_biden_winning`% of our samples, Biden is predicted to have over 270 electoral votes. Thus, we predict Biden will win the election with probability `r prob_of_biden_winning/100`. 

**STICK TABLE 1 ND STVEN'S PLOTS elifuahslkdfjaweifuaskldfjalwLWEIAUFHSLKDFJHAWELIFUHASKDLFJAWEIUAKLSDJFHALWIUEFALKSDJFAWOIEUFKL

Table XXXXX shows the probability of Democratic victory in each swing state. To obtain this probability for each state, we count the number of samples in which Biden's predicted vote share is greater than 50% and divide by 2,000, the total number of samples. We note that there is a low chance of Biden winning in Texas, Ohio and Iowa. However, Colorado, New Hampshire and Maine show promising results for Biden. 

Biden's probabilities of winning Pennsylvania and Wisconsin are the closest to 50%. Figure XXX displays the change in voter preferences in these states since June 1st. ADD ONE-TWO  SENTENCES ABOUT PLOT.

### Model Diagnostics

Traceplots for select parameters and quantiles for values can be found in the Appendix. To determine if our model has converged sufficiently, we first examine traceplots for each of the parameters. Traceplots with random scatter around a mean value indicates that the model has converged. RHAT values provide an estimate of convergence based on the variance of an estimated parameter between chains, and the variance within a chain. The closer the RHAT value to 1, the better the model has converged. The traceplots show the chains have mixed well and RHAT values close to 1, indicating that our model has sufficiently converged. 

### Sensitivity Analysis

```{r fig.align="center"}
sensitivity_plot_presidential + labs(caption = "Figure 2") +
  theme(plot.caption = element_text(hjust = 0.5, vjust = -0.5))
``` 

In Figure 2, we explore the posterior predictive distributions of Biden’s electoral votes across different priors on $\frac{1}{\sigma^2_{0}}$. The solid purple lines indicate the posterior mean of `r mean_electoral` electoral votes from (1). The distribution of Biden's predicted electoral votes appears to be roughly consistent across different priors. Thus, our results are relatively insensitive to prior choice [[7]][Bibliography].

### External Validation

```{r}
# https://www.politico.com/2012-election/swing-state/  used to determine swing states 
polls2012 <- read_csv("all_polls_2012.csv") 

polls2012 <- polls2012 %>% 
  filter(population %in% c("Registered Voters", "Likely Voters")) %>% 
  mutate(state = ifelse(state == "--","US",state)) %>%
  mutate(pct = obama / (obama + romney) *100) %>% 
  mutate(start.date = mdy(start.date),
         end.date = mdy(end.date),
         election_date = "2012-11-06" %>% as.Date(),
         days_to_election = election_date - end.date) %>%
  filter(state %in% c("CO", "FL", "IA", "NV", "NH", "NC", "OH", "VA", "WI") & start.date >= "2012-08-01")

obama_votes <- 237
states_2012 <- polls2012$state %>% unique
y_2012 <- polls2012$pct
r_2012 <- match(polls2012$state,states_2012)
t_2012 <- polls2012$days_to_election + 1 
N_polls_2012 <- y_2012 %>% length
N_states_2012 <- states_2012 %>% length
N_days_2012 <- t_2012 %>% max
I_states_2012 <- diag(N_states_2012)

# obama's vote share in 2008: https://www.nytimes.com/elections/2008/results/president/votes.html
vote_share_2008 <- data.frame(polls2012$state) 
vote_share_2008 <- distinct(vote_share_2008) %>%
  mutate(obama_percent = case_when(
    polls2012.state == "CO" ~ 54/(54 + 45),
    polls2012.state == "FL" ~ 51/(51 + 48),
    polls2012.state == "IA" ~ 54/(54 + 45),
    polls2012.state == "NV" ~ 55/(55 + 43),
    polls2012.state == "NH" ~ 54/(54 + 45),
    polls2012.state == "NC" ~ 50/(50 + 50),
    polls2012.state == "OH" ~ 51/(51 + 47),
    polls2012.state == "VA" ~ 53/(53 + 46),
    polls2012.state == "WI" ~ 56/(56 + 42)
    
  )) %>%
  mutate(obama_percent = 100*obama_percent)
obama2008 <- vote_share_2008$obama_percent

# final model 
gamma_2_0.5_prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(2,0.5)
  "

model_file <- generate_presidential_model_text(gamma_2_0.5_prior)
if (file.exists("gamma_2_0.5_2012.Rds")) {
  presidential2012_model_gamma_2_0.5_prior <- readRDS("gamma_2_0.5_2012.Rds")
} else {
  presidential2012_model_gamma_2_0.5_prior <- jags(data = list(y=y_2012,t=t_2012, r=r_2012, N_polls=N_polls_2012, 
                                                               N_states=N_states_2012, N_days=N_days_2012, h=obama2008, I_states=I_states_2012),  
                                                   parameters.to.save = c("theta", "Sigma", 
                                                                          "p","sigma2_y", "sigma2_0"),
                                                   n.iter = 15000, n.burnin = 5000, n.thin = 10, n.chains = 2,
                                                   model.file = model_file)
  
  saveRDS(presidential2012_model_gamma_2_0.5_prior, file = "gamma_2_0.5_2012.Rds")
}

iterations = presidential2012_model_gamma_2_0.5_prior$BUGSoutput$n.keep * presidential2012_model_gamma_2_0.5_prior$BUGSoutput$n.chains 

electoral_data <- read.csv("Electoral_College.csv") %>%
  filter(Year == 2012)

electoral_data$states_2012 <- c("AL", "AK","AZ","AR","CA","CO","CT","DC",
                                "DE","FL","GA","HI","ID","IL","IN","IA","KS",
                                "KY","LA","ME","MD","MA","MI","MN","MS","MO","MT",
                                "NE","NV","NH","NJ","NM","NY","NC","ND","OH","OK",
                                "OR","PA","RI","SC","SD","TN","TX","UT","VT","VA","WA","WV","WI","WY")

#returns number of electoral votes biden wins for each iteration of the sampler
#we need to add to this the votes that he is guaranteed from other states

prediction_per_simulation_obama <- function(model_output, i){
  elec_sims <- presidential2012_model_gamma_2_0.5_prior$BUGSoutput$sims.list$theta[i,,1]
  vote_share_by_state <- data.frame(states_2012, elec_sims)
  
  
  results <- merge(vote_share_by_state, electoral_data, by = "states_2012") %>%
    dplyr::select(-c(Year)) 
  obama_wins <- results %>%
    filter(elec_sims > 50) 
  obama_electoral_votes <- sum(obama_wins$Votes) 
  
  #add in the number of guaranteed votes from other states!
  biden_votes = obama_votes + obama_electoral_votes
  return(biden_votes)
}

final_results2012 <- c()

for (i in 1:iterations){
  final_results2012[i] = prediction_per_simulation_obama(presidential2012_model_gamma_2_0.5_prior, i)
}

prob_of_obama_winning <- mean(final_results2012 > 270) * 100
mean_electoral <- mean(final_results2012)
lower_q_obama <- quantile(final_results2012, probs = c(0.025))
upper_q_obama <- quantile(final_results2012, probs = c(0.975)) + 4

ggplot(data = tibble(final_results2012),  aes(x = final_results2012)) + 
  geom_histogram(bins = 16, colour="black",fill = "#4d4d4d") + 
  geom_vline(xintercept = 332, color = "#1b7837", size = 1.1) + 
  geom_vline(xintercept = mean_electoral, color = "#542788", size = 1.1) + 
  geom_vline(xintercept = c(lower_q_obama,upper_q_obama), color = "#542788", linetype = 2, size = 0.7) + 
  labs(title = "Predicted Number of Obama's Electoral Votes",
       subtitle = paste0("Predicted Probability of Obama Winning: ", prob_of_obama_winning, "%"),
       x = "Number of Obama's Electoral Votes",
       y = "Count",
       caption = "Figure XXXXXx") +
  theme(plot.caption = element_text(hjust = 0.5, vjust = -0.5))
```

For external validation, we estimate Obama’s electoral vote share in 2012 using (1). We predict the outcomes from 9 swing states: Colorado, Florida, Iowa, Nevada, New Hampshire, North Carolina, Ohio, Virginia, and Wisconsin [SOURCE]. The one difference from the parametrization in (1) is the prior on $\theta_{i 1}$, which now follows a $N(o_i, \sigma^2_0)$ distribution, where $o_i$ represents Obama’s vote share in 2008 from swing state $i \in (1 \dots 9)$. We assume he would win 237 electoral votes from solid blue states [[8]][Bibliography]. Using the prediction methodology outlined in Section 2.2, our 95% credible interval for President Obama’s 2012 electoral vote share is (`r lower_q_obama`, `r upper_q_obama`). This captures the true number of electoral votes he won, 332. Despite President Obama winning in a landslide, this result was uncertain at the time due to misrepresentation of voter sentiment in the polls. Therefore, there is reasonable evidence that our model may generalize well to the 2020 election, given the evidence that it is able to balance prior election results and polling information. 


# US Senate Election

```{r Read in Data}
#Filter to see if any non democratic or republican candidates are polling high
# add New Mexico  and Missisipi 
`%notin%` <- Negate(`%in%`)
senate_polls <- read_csv("senate_polls.csv")
senate_polls$state %>% unique
senate_polls %>%
  filter(cycle == "2020") %>%
  filter(candidate_party %notin% c("DEM", "REP")) %>%
  arrange(desc(pct)) %>%
  select(poll_id, state, candidate_name, candidate_party, pct)

#TOP THREE: DUNBAR, HARRINGTON, WILSON
#Dunbar (AK) is a democrat, but running as an independent against republican and democratic candidates- but as of more recent polls he isn't relevant
#Harrington (AR) is liberatrian running against a republican
#Wilson (IL) is an independent running against a democrat- he can be counted as a democrat 

#filter out AR because there is a 0% chance a democrat wins here
#filter out IL because there is a 100% chance a democrat wins here
#remember to add back in one senator for IL because that's sort of a given!
```

```{r}
senate_polls_cleaned <- senate_polls %>%
  filter(cycle == "2020") %>%
  filter(population %in% c("lv","rv")) %>% 
  filter(office_type == "U.S. Senate") %>%
  
  #add separate elections for georgia and arizona special
  mutate(state = case_when(
    state == "Georgia" & seat_name == "Class III" ~ "Georgia*",
    state == "Arizona" & seat_name == "Class III" ~ "Arizona*",
    TRUE ~ as.character(state)
  )) %>%
  
  #get rid of arkansas because there is no chance that a democrat will win here 
  #get rid of illionis because basically guarantted a democrat wins
  filter(state %notin% c("Arkansas", "Illinois")) %>%
  filter(candidate_party %in% c("DEM", "REP")) %>%
  filter(poll_id != 58956 & question_id != 100828) %>%
  filter(poll_id != 67060 & question_id != 125304) #get rid of weird polls
#senate_polls_cleaned$state %>% unique
```


```{r}
democratic_candidates <- senate_polls_cleaned %>%
  dplyr::filter(candidate_party == "DEM") %>%
  dplyr::group_by(question_id, poll_id, state, race_id, pollster, start_date, end_date) %>%
  dplyr::summarize(total_dems_pct = sum(pct)) 
#democratic_candidates 
```

```{r}
republican_candidates <- senate_polls_cleaned %>%
  dplyr::filter(candidate_party == "REP") %>%
  dplyr::group_by(question_id, poll_id, state, race_id, pollster, start_date, end_date) %>%
  dplyr::summarize(total_rep_pct = sum(pct)) 
#republican_candidates
```

```{r}
senate_data <- merge(democratic_candidates, republican_candidates, by = c("state", "question_id", "poll_id", "race_id", "pollster", "start_date", "end_date"))
senate_data <- senate_data %>%
  mutate(pct_dem = 100*total_dems_pct/(total_dems_pct + total_rep_pct))
#senate_data
```

```{r}
senate <- senate_data %>%
  mutate(start_date = mdy(start_date),
         end_date = mdy(end_date),
         election_date = "2020-11-03" %>% as.Date(),
         days_to_election = election_date - end_date,
         y = pct_dem) %>%
  dplyr::filter(days_to_election <= 100) %>%
  filter(state %in% c("Alaska", "Alabama", "Arizona*", "Colorado", "Georgia*", "Georgia", "Iowa", "Kansas", "Kentucky",
                      "Maine", "Michigan", "Minnesota", "Mississippi",
                      "Montana", #"New Hampshire",
                      "New Mexico",
                      "North Carolina", "South Carolina", "Texas")) #THIS is 538 (Kentucky+NH are  kinda red and kinda blue)

# filter(state %in% c("Alabama", "Arizona*", "Colorado", "Georgia*", "Georgia", "Iowa", "Kansas", "Kentucky",
#                     "Maine", "Michigan", "Minnesota", 
#                     "Montana", "New Hampshire",
#                     
#                     "North Carolina", "South Carolina", "Texas")) #  THIS is ballotpedia states
```


```{r senate jags data}
states_senate <- senate$state %>% unique
y_senate <- senate$y
r_senate <- match(senate$state,states_senate)
t_senate <- senate$days_to_election + 1 
N_polls_senate <- y_senate %>% length
N_states_senate <- states_senate %>% length
N_days_senate <- t_senate %>% max
I_states_senate <- diag(N_states_senate)
jags_data_senate <- list(y=y_senate,t=t_senate,r=r_senate,
                         N_polls=N_polls_senate,N_states=N_states_senate,N_days=N_days_senate, I_states=I_states_senate)
```

```{r}
generate_senate_model_text = function(hierarchical_priors_senate) {
  model_file <- tempfile()
  likelihood_base_priors = "
  for(k in 1:N_polls){
    y[k] ~ dnorm(p[k],1/sigma2_y[r[k]]) #note no longer binomial
    p[k] = theta[r[k],t[k]] 
  }
  for(j in 2:N_days){
    theta[1:N_states,j] ~ dmnorm(theta[1:N_states,j-1],Phi)
  }
  
  Phi ~ dwish(I_states,N_states+1) 
  Sigma = inverse(Phi)
  #hierarchical component
  for(j in 1:N_states){
    sigma2_y[j] = 1/sigma2_y_inv[j]
    sigma2_y_inv[j] ~ dgamma(nu_y,nu_y*tau_y) 
    
    theta[j,1] ~ dnorm(mu0, sigma2_0)
  }
  "
  
  model_text <- paste("model{ ", likelihood_base_priors, hierarchical_priors_senate,"}")
  writeLines(model_text,con=model_file)
  return(model_file)
}
```

```{r final senate model}
senate_gamma_2_1_mu_7.5.prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  mu0 ~ dnorm(50, pow(7.5,-1)) 
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(2,1) 
  "

model_file_senate_gamma_2_1_mu_7.5.prior <- generate_senate_model_text(senate_gamma_2_1_mu_7.5.prior) 
if (file.exists("senate_gamma_2_1_mu_7.5.prior.Rds")) { 
  senate_gamma_2_1_mu_7.5.prior_model <- readRDS("senate_gamma_2_1_mu_7.5.prior.Rds") 
} else {
  senate_gamma_2_1_mu_7.5.prior_model <- jags(data = jags_data_senate,  
                                              parameters.to.save = c("theta", "Sigma", 
                                                                     "p","sigma2_y", "sigma2_0"),
                                              n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                              model.file = model_file_senate_gamma_2_1_mu_7.5.prior)
  
  saveRDS(senate_gamma_2_1_mu_7.5.prior_model, file = "senate_gamma_2_1_mu_7.5.prior.Rds")
}
```


```{r}
n_iter <- dim(senate_gamma_2_1_mu_7.5.prior_model$BUGSoutput$sims.list$theta[,,1])[1]

prediction_per_simulation_senate <- function(model_output, i){
  elec_sims <- model_output$BUGSoutput$sims.list$theta[i,,1]
  vote_share_by_state <- data.frame(states_senate, elec_sims)
  
  dem_states_df <- vote_share_by_state %>%
    filter(elec_sims > 50)
  dem_states <- dem_states_df$states_senate
  num_dem_states <- length(dem_states)
  return(num_dem_states)
}

final_results_senate <- c()

for (i in 1:n_iter){
  final_results_senate[i] = prediction_per_simulation_senate(senate_gamma_2_1_mu_7.5.prior_model, i) 
}

mean_senate <- mean(final_results_senate) 
lower_q_senate <- quantile(final_results_senate, probs = c(0.025)) 
upper_q_senate <- quantile(final_results_senate, probs = c(0.975)) 

senate_results_plot <- ggplot(data = tibble(final_results_senate),  aes(x = final_results_senate)) + 
  geom_histogram(bins = 18, colour="black",fill = "#4d4d4d") + 
  geom_vline(xintercept = 8, color = "#1b7837", size = 1.1) + 
  geom_vline(xintercept = mean_senate, color = "#542788", size = 1.1) + 
  geom_vline(xintercept = c(lower_q_senate,upper_q_senate), color = "#542788", linetype = 2, size = 0.7) + 
  labs(title = "Predicted Number Battleground Races Going Democrat",
       subtitle = paste0("Predicted Probability of Senate Flipping: ", mean(final_results_senate >= 8) * 100, "%"),
       x = "Number Battleground Races Going Democrat",
       y = "Count")
```


```{r}
senate_gamma_5_2_mu_7.5.prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  mu0 ~ dnorm(50, pow(7.5,-1)) 
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(5,2) 
  "

model_file_senate_gamma_5_2_mu_7.5.prior <- generate_senate_model_text(senate_gamma_5_2_mu_7.5.prior) 
if (file.exists("senate_gamma_5_2_mu_7.5.prior.Rds")) { 
  senate_gamma_5_2_mu_7.5.prior_model <- readRDS("senate_gamma_5_2_mu_7.5.prior.Rds") 
} else {
  senate_gamma_5_2_mu_7.5.prior_model <- jags(data = jags_data_senate,  
                                              parameters.to.save = c("theta", "Sigma", 
                                                                     "p","sigma2_y", "sigma2_0"),
                                              n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                              model.file = model_file_senate_gamma_5_2_mu_7.5.prior)
  
  saveRDS(senate_gamma_5_2_mu_7.5.prior_model, file = "senate_gamma_5_2_mu_7.5.prior.Rds")
}

# final_results_senate <- c()
# 
# for (i in 1:n_iter){
#   final_results_senate[i] = prediction_per_simulation_senate(senate_gamma_5_2_mu_7.5.prior_model, i)
# }
# 
# mean(final_results_senate >= 9)
# mean(final_results_senate)
# final_results_senate %>% hist()
# 
# tidybayes::gather_draws(senate_gamma_5_2_mu_7.5.prior_model %>% as.mcmc() %>% mcmc.list() , theta[i, j]) %>%
#   filter(i == 1 & j == 1) %>%
#   mutate(param = ifelse(is.na(i), .variable, paste0(.variable,"[", i,", ", j, "]"))) %>%
#   ggplot(aes(x = .iteration, y = .value, color = as.factor(.chain))) +
#   geom_line(alpha = 0.6) +
#   facet_grid(param~., scales = "free_y")
```

```{r}
senate_gamma_2_2_mu_10.prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  mu0 ~ dnorm(50, pow(10,-1)) 
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(0.5,0.5) 
  "

model_file_senate_gamma_2_2_mu_10.prior <- generate_senate_model_text(senate_gamma_2_2_mu_10.prior) 
if (file.exists("senate_gamma_2_2_mu_10.prior.Rds")) { 
  senate_gamma_2_2_mu_10.prior_model <- readRDS("senate_gamma_2_2_mu_10.prior.Rds") 
} else {
  senate_gamma_2_2_mu_10.prior_model <- jags(data = jags_data_senate,  
                                             parameters.to.save = c("theta", "Sigma", 
                                                                    "p","sigma2_y", "sigma2_0"),
                                             n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                             model.file = model_file_senate_gamma_2_2_mu_10.prior)
  
  saveRDS(senate_gamma_2_2_mu_10.prior_model, file = "senate_gamma_2_2_mu_10.prior.Rds")
}

# final_results_senate <- c()
# 
# for (i in 1:n_iter){
#   final_results_senate[i] = prediction_per_simulation_senate(senate_gamma_2_2_mu_10.prior_model, i)
# }
# 
# mean(final_results_senate >= 9)
# mean(final_results_senate)
# final_results_senate %>% hist()
# 
# tidybayes::gather_draws(senate_gamma_2_2_mu_10.prior_model %>% as.mcmc() %>% mcmc.list() , theta[i, j]) %>%
#   filter(i == 1 & j == 1) %>%
#   mutate(param = ifelse(is.na(i), .variable, paste0(.variable,"[", i,", ", j, "]"))) %>%
#   ggplot(aes(x = .iteration, y = .value, color = as.factor(.chain))) +
#   geom_line(alpha = 0.6) +
#   facet_grid(param~., scales = "free_y")
```

```{r}
senate_gamma_0.5_0.5_mu_10.prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  mu0 ~ dnorm(50, pow(10,-1)) 
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(0.5,0.5) 
  "

model_file_senate_gamma_0.5_0.5_mu_10.prior <- generate_senate_model_text(senate_gamma_0.5_0.5_mu_10.prior) 
if (file.exists("senate_gamma_0.5_0.5_mu_10.prior.Rds")) { 
  senate_gamma_0.5_0.5_mu_10.prior_model <- readRDS("senate_gamma_0.5_0.5_mu_10.prior.Rds") 
} else {
  senate_gamma_0.5_0.5_mu_10.prior_model <- jags(data = jags_data_senate,  
                                                 parameters.to.save = c("theta", "Sigma", 
                                                                        "p","sigma2_y", "sigma2_0"),
                                                 n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                                 model.file = model_file_senate_gamma_0.5_0.5_mu_10.prior)
  
  saveRDS(senate_gamma_0.5_0.5_mu_10.prior_model, file = "senate_gamma_0.5_0.5_mu_10.prior.Rds")
}

# final_results_senate <- c()
# 
# for (i in 1:n_iter){
#   final_results_senate[i] = prediction_per_simulation_senate(senate_gamma_0.5_0.5_mu_10.prior_model, i)
# }
# 
# mean(final_results_senate >= 9)
# mean(final_results_senate)
# final_results_senate %>% hist()
```

```{r senate model sensitivity plots, cache=TRUE}
senate_sen_analysis_priors_names <- c("Ga(2, 1), Mu(50, 1/7.5)",
                                      "Ga(5, 2), Mu(50, 1/7.5)",
                                      "Ga(2, 2), Mu(50, 1/10)",
                                      "Ga(0.5, 0.5), Mu(50, 1/10)")   
senate_sen_analysis_priors <- list(senate_gamma_2_1_mu_7.5.prior_model,
                                   senate_gamma_5_2_mu_7.5.prior_model,
                                   senate_gamma_2_2_mu_10.prior_model,
                                   senate_gamma_0.5_0.5_mu_10.prior_model)   



senate_sen_tbl_list <- list()
for (i in 1:4) {
  final_results_senate_sensitivity <- c()
  for (sim in 1:iterations) {
    
    final_results_senate_sensitivity[sim] = prediction_per_simulation_senate(senate_sen_analysis_priors[[i]], sim)
  }
  senate_sen_tbl_list[[i]] <- as_tibble(final_results_senate_sensitivity)
}


sensitivity_plot_senate <- do.call(bind_rows, senate_sen_tbl_list) %>% 
  dplyr::mutate(model = rep(sen_analysis_priors_names, each=2000),
                model = factor(model,
                               levels = sen_analysis_priors_names,
                               labels = c(expression(paste(sigma[0]^2, " ~ Ga(2, 1), ", mu[0], " ~ (50, 1/7.5)")),
                                          expression(paste(sigma[0]^2, " ~ Ga(5, 2), ", mu[0]," ~ (50, 1/7.5)")),
                                          expression(paste(sigma[0]^2, " ~ Ga(2, 2), ", mu[0]," ~ (50, 1/10)",)),
                                          expression(paste(sigma[0]^2, " ~ Ga(0.5, 0.5), ", mu[0]," ~ (50, 1/10"))))) %>% 
  ggplot() + 
  geom_density(aes(x = value)) + 
  #geom_histogram(aes(x = value), bins = 10) + 
  geom_vline(xintercept = mean_senate, color = "blue") + 
  geom_vline(xintercept = c(lower_q_senate,upper_q_senate), color = "red", linetype = 2) + 
  facet_wrap(model~., scales = "free_y", labeller = "label_parsed") + 
  labs(title = "Predicted Number of Biden's Electoral Votes",
       x = "Number of Biden's Electoral Votes",
       y = "Density") 
```

# Senate

The Senate currently has 53 Republicans and 47 Democrats (including 2 Independents who caucus with the Democratic party). 35 Democrats and 30 Republicans are *not* up for election in 2020, while the 35 remaining seats are up. Thus, in order to reach 51 and “flip” the Senate, Democrats will need to win 16 of the 35 seats up for election. Of the 35 seats up, 8 are in states that are very likely to vote for the Democratic candidate (Virginia, Oregon, Illinois, New Jersey, Delaware, Massachusetts, New Hampshire, and Rhode Island) while 9 states are very likely to vote Republican (Arkansas, Idaho, Louisiana, Nebraska, Oklahoma, Tennessee, South Dakota, West Virginia and Wyoming) [[15]][Bibliography]. The remaining 18 races (in 17 states) will be instrumental in determining if the senate flips: Alaska, Alabama, Arizona, Colorado, Georgia, Iowa, Kansas, Kentucky, Maine, Michigan, Minnesota, Mississippi, Montana, New Mexico, North Carolina, South Carolina, and Texas [[15]][Bibliography]. These include two special elections [[13]][Bibliography]: one in Arizona and one in Georgia (where both seats are up). Of these 18 races, Democrats need to win 8 in order to reach 16 seats and flip the senate. For this reason, we are primarily interested in modelling the outcomes in only these 18 “battleground” races. 

## Data

To predict the outcomes of US senate races, we utilize state-wide 2020 senate election polls. Each sample in the dataset includes the start date of the poll, the percentages of people who would vote for the Democratic or Republican candidate, and whether the sampled population were “likely” voters, registered voters, or simply adults. In Arizona and Georgia’s special elections, multiple candidates from each party are facing off on Election Day. For this reason, we collapse all Democratic candidates into one group and all Republican candidates into another, and aggregate their polling numbers. For example, Arizona’s Democratic candidates are classified as a single candidate with one overall percentage. 

We only kept polls that sample populations of registered and likely voters. We further filtered the data to only include polls from 100 days before Election Day, which is around most states’ primary election dates [[14]][Bibliography]. Furthermore, we designated special elections in Georgia and Arizona as Georgia* and Arizona*, respectively, in order to avoid confusing these elections with their main counterparts. For each poll, we calculated the Democratic candidate’s share of the two-party vote by dividing the Democratic candidate’s percentage by the sum of the Republican’s and Democratic’s percentages.


## Methods

We utilize the polling data in a model similar to that of the presidential election.  

$$
\begin{aligned}
Y_{k} \sim  N(\theta_{i[k]t[k]},\sigma^2_{yi}) \\ 
\theta_{i 1} \sim N(\mu_0, \sigma^2_0) , \ \boldsymbol{\theta}_{\boldsymbol{ \cdot} t} \sim MVN&(\boldsymbol{\theta}_{\boldsymbol{\cdot} t-1},\mathbf{\Sigma}) \\ 
\mu_0 \sim N(50, \frac{2}{15}), \ \mathbf{\Sigma}^{-1} \sim Wis&h(\mathbf{I_{18}}, 19) &  (2) \\
\frac{1}{\sigma^2_{yi}} \sim Ga(\nu_y,\nu_y*\tau_y) , \ \frac{1}{\sigma^2_{0}} \sim  \ &Ga(2, 1)\\
\nu_y \sim Unif(0,100), \ \tau_y \sim Un&if(0,100)\\
\end{aligned}
$$

(2) represents the final model we use to predict the presidential election. Let $Y_k$, the Democratic candidate’s share of the two-party vote from each poll $k$, be normally distributed with mean $\theta_{i[k]t[k]}$, where poll $k$ ended $t$ days before the election and was conducted in battleground race $i \in (1 \dots 18)$. Each race $i$ has its own observation variance, $\sigma^2_{yi}$, where the indice $y$ indicates that it is the observation variance from each race. We set a Gamma prior on $\frac{1}{\sigma^2_{yi}}\sim Ga(\nu_y,\nu_y*\tau_y)$, where both $\nu_y, \tau_y \sim Unif(0,100)$. We set normal priors on $\boldsymbol{\theta}_{\boldsymbol{ \cdot}  1}$, centered about 50 with variance $\sigma^2_0$. Note that, unlike the model for the Presidential election, we did not center $\boldsymbol{\theta}_{\boldsymbol{ \cdot}  1}$ around vote shares from previous senate elections in each state. This was due to the fact that, barring special elections, the last senate elections for this group of states occurred six years ago. As this is a considerable amount of time, we did not believe it sensible to strongly center our priors on the previous election.  Since we also estimate the correlation structure between states, we let $\boldsymbol{\theta}_{\boldsymbol{ \cdot} t} \sim MVN(\boldsymbol{\theta}_{\boldsymbol{\cdot} t-1},\mathbf{\Sigma})$, where $\mathbf{\Sigma}^{-1} \sim Wish(\mathbf{I_{18}}, 19)$. 

Using JAGS, we run (2) with 2 chains, each with 75,000 simulations, 25,000 burn-in, and thinned the sampler by keeping every 50th sample. This leaves us with 2,000 samples. Then, for each sample, we performed the following:

1. Extract the 18 values of  $\theta_{\cdot 1}$, the Democratic candidate’s estimated vote share on the day of the election from each battleground race $i \in (1 \dots 18)$.
2. If $\theta_{i 1}$ > 50%, the model predicts the Democratic candidate will win in race $i$.  
3. 8 races are very likely to elect the Democratic candidate [[15]][Bibliography]. If Democratic candidates win in at least 8 swing races, the Senate will flip.  

We iterate this process for each of the 2,000 samples to predict the outcome of the U.S. Senate election.

## Results

```{r}
senate_results_plot + labs(caption = "Figure XXXX") +
  theme(plot.caption = element_text(hjust = 0.5, vjust = -0.5))
```

Figure XXXXX displays the posterior predictions for the number of senate seats Democrats will win, out of the 18 seats up for reelection which we deemed “battleground.” The green line is drawn at 8 and the solid and dashed purple lines indicate the mean and 95% credible interval, respectively. The posterior predictions indicate Democrats will win an average of `r mean_senate` of the 18 battleground seats, with a 95% credible interval of (`r lower_q_senate`, `r upper_q_senate`). In `r mean(final_results_senate >= 8) * 100`% of our samples, Democrats are predicted to win at least 8 battleground senate seats. Thus, adding this number to the 8 already guaranteed to Democrats, we predict that Democrats will win 16 seats and “flip” the senate with probability `r mean(final_results_senate >= 8)`. 


**STICK TABLE 1 ND STVEN'S PLOTS elifuahslkdfjaweifuaskldfjalwLWEIAUFHSLKDFJHAWELIFUHASKDLFJAWEIUAKLSDJFHALWIUEFALKSDJFAWOIEUFKL

```{r}
predictions_per_state_senate <- function(model_output, state){
  win_dem <- c()
  for (i in 1:iterations){
    
    elec_sims <- model_output$BUGSoutput$sims.list$theta[i,,1]
    vote_share_for_state <- data.frame(states_senate, elec_sims) %>%
      filter(states_senate == state)
    vote_share_val <- vote_share_for_state$elec_sims
    if (vote_share_val > 50){
      win_dem[i] <- 1
    }
    if (vote_share_val < 50){
      win_dem[i] <- 0
    }
  }
  probability_voting_dem <- round(100*sum(win_dem)/iterations, 3)
  return(probability_voting_dem)
}
probs_voting_dem <- c()
i = 1
for (state in states_senate){
  # print(state)
  prob_voting_dem <- predictions_per_state_senate(senate_gamma_2_1_mu_7.5.prior_model, state)
  # print(prob_voting_dem)
  probs_voting_dem[i] <- prob_voting_dem
  i = i + 1
}
prob_voting_dem_table <- data.frame(states_senate, probs_voting_dem) %>%
  mutate(State = states_senate) %>%
  mutate(Probability = probs_voting_dem/100) %>%
  select(State, Probability)
kable(prob_voting_dem_table, caption = "Senate Elections: Probability of Democratic Victory in each Swing State")
```

Table XXXXX shows the probability of a Democratic senate victory for each battleground race. To obtain this probability for each state, we count the number of samples in which the predicted vote share is greater than 50% and divide by 2,000, the total number of samples. There is a low probability of Democrats winning senate seats in Alabama and Kentucky, while Colorado and Michigan show promising results for Democrats. 

Biden's probabilities of winning Pennsylvania and Wisconsin are the closest to 50%. Figure XXX displays the change in voter preferences in these states since June 1st. ADD ONE-TWO  SENTENCES ABOUT PLOT. FIX THIS PLS

### Model Diagnostics

Traceplots for select parameters and quantiles for values can be found in the Appendix. To determine if our model has converged sufficiently, we first examine traceplots for each of the parameters. Traceplots with random scatter around a mean value indicates that the model has converged. RHAT values provide an estimate of convergence based on the variance of an estimated parameter between chains, and the variance within a chain. The closer the RHAT value to 1, the better the model has converged. The traceplots show the chains have mixed well and RHAT values close to 1, indicating that our model has sufficiently converged. 

### Sensitivity Analysis

```{r}
sensitivity_plot_senate  + labs(caption = "Figure XXXX") +
  theme(plot.caption = element_text(hjust = 0.5, vjust = -0.5))
```


In Figure XXXX, we explore the posterior predictive distributions of number of seats Democrats will win across different priors on $\frac{1}{\sigma^2_{0}}$ and $\mu_0$. The solid purple lines indicate the posterior mean of `r mean_electoral` number of seats from (2). The distribution of the number of seats Democrats will win does not appear to be roughly consistent across different priors. Thus, our results are slightly sensitive to prior choice [[7]][Bibliography].

### External Validation

```{r}
AZ_senate_vote_shares <- senate_gamma_2_1_mu_7.5.prior_model$BUGSoutput$sims.list$theta[,3,1]

mean_AZ_senate_vote_shares <- mean(AZ_senate_vote_shares) 
lower_AZ_senate_vote_shares <- quantile(AZ_senate_vote_shares, probs = c(0.025)) 
upper_AZ_senate_vote_shares <- quantile(AZ_senate_vote_shares, probs = c(0.975)) 

AZsenate_results_plot <- ggplot(data = tibble(AZ_senate_vote_shares),  aes(x = AZ_senate_vote_shares)) + 
  geom_histogram(bins = 18, colour="black",fill = "#4d4d4d") + 
  geom_vline(xintercept = 50, color = "#1b7837", size = 1.1) + 
  geom_vline(xintercept = 51.2295, color = "#bf812d", size = 1.1) + 
  geom_vline(xintercept = mean_AZ_senate_vote_shares, color = "#542788", size = 1.1) + 
  geom_vline(xintercept = c(lower_AZ_senate_vote_shares,upper_AZ_senate_vote_shares), color = "#542788", linetype = 2, size = 0.7) + 
  labs(title = "Predicted Democratic Vote Share in Arizona (Special Election)",
       subtitle = paste0("Predicted Probability of Mark Kelly (Dem) Winning: ", (prob_voting_dem_table %>% filter(State == "Arizona*") %>% pull(Probability)) * 100, "%"),
       x = "Predicted Vote Share",
       y = "Count")
AZsenate_results_plot + labs(caption = "Figure XXXX") +
  theme(plot.caption = element_text(hjust = 0.5, vjust = -0.5))
```

```{r}
GA_senate_vote_shares <- senate_gamma_2_1_mu_7.5.prior_model$BUGSoutput$sims.list$theta[,6,1]

mean_GA_senate_vote_shares <- mean(GA_senate_vote_shares) 
lower_GA_senate_vote_shares <- quantile(GA_senate_vote_shares, probs = c(0.025)) 
upper_GA_senate_vote_shares <- quantile(GA_senate_vote_shares, probs = c(0.975)) 

GAsenate_results_plot <- ggplot(data = tibble(GA_senate_vote_shares),  aes(x = GA_senate_vote_shares)) + 
  geom_histogram(bins = 18, colour="black",fill = "#4d4d4d") + 
  geom_vline(xintercept = 50, color = "#1b7837", size = 1.1) + 
  geom_vline(xintercept = 42.797, color = "#bf812d", size = 1.1) + 
  geom_vline(xintercept = mean_GA_senate_vote_shares, color = "#542788", size = 1.1) + 
  geom_vline(xintercept = c(lower_GA_senate_vote_shares,upper_GA_senate_vote_shares), color = "#542788", linetype = 2, size = 0.7) + 
  labs(title = "Predicted Democratic Vote Share in Georgia (Special Election)",
       subtitle = paste0("Predicted Probability of Democratic Candidate Winning: ", (prob_voting_dem_table %>% filter(State == "Georgia*") %>% pull(Probability)) * 100, "%"),
       x = "Predicted Vote Share",
       y = "Count")
GAsenate_results_plot + labs(caption = "Figure XXXX") +
  theme(plot.caption = element_text(hjust = 0.5, vjust = -0.5))
```


## Discussion

## Discussion PRESIDENTIAL

One strength of our model is the covariance estimates that pull information of voter preferences between similar states. In this manner, we can capture interstate trends in our model. On the other hand, a limitation to this model is the necessity to classify swing states. There is no strict definition of what defines a swing state, so our model is reliant on these choices. This limitation leads to an assumption of the minimal number of electoral college votes Biden would earn. Further, this influences the covariance matrix, as it pulls information from other swing states involved in the model. 

## North Carolina Senate Election

# Congressional Elections

## Data

## Methods

## Results

### Model Diagnostics

### Sensitivity Analysis

### External Validation

## Discussion

# Conclusion

# Appendix A

# Appendix B

# Bibliography

1). “Braced for impact; America's presidential election." The Economist, 10 Oct. 2020, p. 66(US). Gale OneFile: CPI.Q, https://link.gale.com/apps/doc/A637802159/CPI?u=duke_perkins&sid=CPI&xid=e45fed0d. Accessed 28 Oct. 2020.
2). Martin, Susan F. “Commentary: The 2020 U.S. Presidential Election and Immigration.” International Migration, vol. 58, no. 5, 2020, pp. 274–276., doi:10.1111/imig.12772. 
3). Drew A. Linzer (2013) Dynamic Bayesian Forecasting of Presidential Elections in the States, Journal of the American Statistical Association, 108:501, 124-134, DOI: 10.1080/01621459.2012.737735
4). Linge, M. (2020, October 31). Inside the nine swing states the 2020 presidential election hinges on. Retrieved November 01, 2020, from https://nypost.com/2020/10/31/the-9-swing-states-the-2020-presidential-election-hinges-on/
5). Tamman, M., & Faulconbridge, G. (2016, November 09). How the polls, including ours, missed Trump's victory. Retrieved November 01, 2020, from https://www.reuters.com/article/us-usa-election-polls/how-the-polls-including-ours-missed-trumps-victory-idUSKBN1343O6
6). Hoff, P. D. (2010). Chapter 1: Introduction and examples. In A first course in bayesian statistical methods (pp. 5-7). Dordrecht: Springer.






# NC Senate

## Results 

```{r}
NC_senate_vote_shares <- senate_gamma_2_1_mu_7.5.prior_model$BUGSoutput$sims.list$theta[,16,1]

mean_NC_senate_vote_shares <- mean(NC_senate_vote_shares) 
lower_NC_senate_vote_shares <- quantile(NC_senate_vote_shares, probs = c(0.025)) 
upper_NC_senate_vote_shares <- quantile(NC_senate_vote_shares, probs = c(0.975)) 

NCsenate_results_plot <- ggplot(data = tibble(NC_senate_vote_shares),  aes(x = NC_senate_vote_shares)) + 
  geom_histogram(bins = 18, colour="black",fill = "#4d4d4d") + 
  geom_vline(xintercept = 50, color = "#1b7837", size = 1.1) + 
  geom_vline(xintercept = mean_NC_senate_vote_shares, color = "#542788", size = 1.1) + 
  geom_vline(xintercept = c(lower_NC_senate_vote_shares,upper_NC_senate_vote_shares), color = "#542788", linetype = 2, size = 0.7) + 
  labs(title = "Cunningham's Predicted Vote Share",
       subtitle = paste0("Predicted Probability of Cunningham Winning: ", (prob_voting_dem_table %>% filter(State == "North Carolina") %>% pull(Probability)) * 100, "%"),
       x = "Predicted Vote Share",
       y = "Count")
NCsenate_results_plot + labs(caption = "Figure XXXX") +
  theme(plot.caption = element_text(hjust = 0.5, vjust = -0.5))
```

We can further use (2) to examine the results of the North Carolina Senate election more closely, a hotly contested election between Republican Thom Tillis and Democrat Cal Cunningham. Figure  XXX displays the posterior predictive distribution of Cunningham's vote share. Our posterior mean vote share going to Cunningham is `r mean_NC_senate_vote_shares`, with a 95% credible interval of (`r lower_NC_senate_vote_shares`, `r upper_NC_senate_vote_shares`). We further note that in `r prob_voting_dem_table %>% filter(State == "North Carolina") %>% pull(Probability)) * 100`% of the posterior samples, the predicted vote share for Cunningham was above 50%. Thus, we predict that Cunningham will win the North Carolina senate race with probability `r (prob_voting_dem_table %>% filter(State == "North Carolina") %>% pull(Probability))`, which is promising for the Democratic party. 


