---
title: "Case Study 3: Election Predictions"
author: "Ethan Shen, Malavi Ravindran, Steven Herrera Tenorio, Anna Darwish"
geometry: "left=1.25cm,right=1.25cm,top=1.3cm,bottom=1.3cm"
fontsize: 12pt
output: 
  pdf_document:
     number_sections: true
---

```{r, function checking for installed packages, include=FALSE}
# Validate that all necessary packaged have been downloaded, install otherwise or throw err package DNE
pkgTest <- function(x)
{
  if (!require(x,character.only = TRUE))
  {
    install.packages(x,repos = "http://cran.r-project.org", dep=TRUE)
    if(!require(x,character.only = TRUE)) stop("Package not found")
  }
}
```

```{r package test, include=FALSE}
# Installing packages 
# Additionally, if you are struggling to download RJags, please visit the following link for help. It can also help to try to download the package locally or in RStudio Cloud: https://sites.google.com/a/utexas.edu/edm-principalstratification/downloading-installing-r-jags-rstudio
pkgTest("ggplot2")
pkgTest("lubridate")
pkgTest("R2jags")
pkgTest("tidyverse")
pkgTest("coda")
pkgTest("kableExtra")
pkgTest("matrixStats")
```

```{r load packages, include=FALSE, results="hide"}
library(ggplot2)
library(lubridate)
library(R2jags)
library(tidyverse)
library(coda)
library(kableExtra)
library(matrixStats)
```

```{r}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE)
ggplot2::theme_set(theme_bw())
```

```{r Read in Presidential Polls Data}
president_polls <- read_csv("2020 US presidential election polls - all_polls.csv") %>% 
  filter(population %in% c("lv","rv")) %>% 
  mutate(state = ifelse(state == "--","US",state)) %>%
  mutate(pct = biden / (biden + trump) *100) 

#colnames(president_polls)

president_polls <- president_polls %>% 
  mutate(start.date = mdy(start.date),
         end.date = mdy(end.date),
         election_date = "2020-11-03" %>% as.Date(),
         days_to_election = election_date - end.date)

president_polls <- president_polls[president_polls$start.date >= "2020-06-01",]

president_polls <- president_polls %>%
  filter(state %in% c("AZ", "CO", "FL", "GA", "IA", "ME", "MI", "NC", "OH", "PA", "TX", "WI", "MN", "NV", "NH"))

#got rid of US: why? covariance matrix will be hard to estimate
#swing states are: Arizona, Colorado, Florida, Georgia, Iowa, Maine, Michigan, North Carolina, Ohio, Pennsylvania, Texas, Wisconsin, Minnesota, Nevada, New Hampshire
#these were determined from the following map and external sources: https://www.270towin.com/. 
#should we get rid of "US"? The popular vote doesn't really matter anyways. 
```

```{r include=FALSE}
#which states are not represented at all in polling data? none are swing, so we're good
# State_Abbrev <- c("AL", "AK","AZ","AR","CA","CO","CT","DC",
#                   "DE","FL","GA","HI","ID","IL","IN","IA","KS",
#                   "KY","LA","ME","MD","MA","MI","MN","MS","MO","MT",
#                   "NE","NV","NH","NJ","NM","NY","NC","ND","OH","OK",
#                   "OR","PA","RI","SC","SD","TN","TX","UT","VT","VA","WA","WV","WI","WY")

```

```{r include=FALSE}
# swing <- c("AZ", "CO", "FL", "GA", "IA", "ME", "MI", "NC", "OH", "PA", "TX", "WI", "MN", "NV", "NH")
# State_Abbrev[!(State_Abbrev %in% swing)]
```

```{r votes going to Biden}
#going to biden:
biden <- c(55, 7, 3, 3, 4, 20, 10, 11, 14, 5, 29, 7, 4, 3, 13, 12)
dem_states <- c("CA", "CT", "DC", "DE", "HI", "IL", "MD", "MA", "NJ", "NM", "NY", "OR", "RI", "VT", "VA", "WA")
votes_going_to_biden <- sum(biden)
#votes_going_to_biden
```

```{r presidential data_list}
states <- president_polls$state %>% unique
y <- president_polls$pct
r <- match(president_polls$state,states)
t <- president_polls$days_to_election + 1 
N_polls <- y %>% length
N_states <- states %>% length
N_days <- t %>% max
I_states <- diag(N_states)
```

```{r clinton vote share priors}
#"AZ", "CO", "FL", "GA", "IA", "ME", "MI","MN","NC", "NV", "NH", "OH", "PA", "TX", "WI"
vote_share_2016 <- data.frame(president_polls$state, number = r)
vote_share_2016 <- unique(vote_share_2016) %>%
  mutate(clinton_percent = case_when(
    president_polls.state == "AZ" ~ 45/(48 + 45),
    president_polls.state == "CO" ~ 47/(47 + 44),
    president_polls.state == "FL" ~ 48/(48 + 49),
    president_polls.state == "GA" ~ 46/(46 + 51),
    president_polls.state == "IA" ~ 42/(42 + 52),
    president_polls.state == "ME" ~ 48/(48 + 45),
    president_polls.state == "MI" ~ 47/(47 + 48),
    president_polls.state == "MN" ~ 47/(47 + 45),
    president_polls.state == "NC" ~ 47/(47 + 51),
    president_polls.state == "NH" ~ 48/(48 + 47),
    president_polls.state == "NV" ~ 48/(48 + 46),
    president_polls.state == "OH" ~ 44/(44 + 52),
    president_polls.state == "PA" ~ 48/(48 + 49),
    president_polls.state == "TX" ~ 43/(43 + 53),    
    president_polls.state == "WI" ~ 47/(47 + 48)
    
    
    
    
    
    
  )) %>%
  mutate(clinton_percent = 100*clinton_percent)
h <- vote_share_2016$clinton_percent
```

```{r}
generate_presidential_model_text = function(hierarchical_priors) {
  model_file <- tempfile()
  likelihood_base_priors = "
  for(k in 1:N_polls){
    y[k] ~ dnorm(p[k],1/sigma2_y[r[k]]) #note no longer binomial
    p[k] = theta[r[k],t[k]] 
  }
  for(j in 2:N_days){
    theta[1:N_states,j] ~ dmnorm(theta[1:N_states,j-1], Phi)
  }
  
  Phi ~ dwish(I_states,N_states+1) 
  Sigma = inverse(Phi)
  
  #hierarchical component
  for(i in 1:N_states){
    sigma2_y[i] = 1/sigma2_y_inv[i]
    sigma2_y_inv[i] ~ dgamma(nu_y,nu_y*tau_y) 
    
    theta[i,1] ~ dnorm(h[i], sigma2_0)
  }
  "
  
  model_text <- paste("model{ ", likelihood_base_priors, hierarchical_priors,"}")
  writeLines(model_text,con=model_file)
  return(model_file)
}
```


```{r final presidential model}
# final model 
gamma_2_0.5_prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  nu_beta ~ dunif(0,100)
  tau_beta ~ dunif(0,100)
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(2, 0.5)
  "

model_file <- generate_presidential_model_text(gamma_2_0.5_prior)
if (file.exists("gamma_2_0.5.Rds")) {
  presidential_model_gamma_2_0.5_prior <- readRDS("gamma_2_0.5.Rds")
} else {
  presidential_model_gamma_2_0.5_prior <- jags(data = list("y","t", "r", "N_polls", 
                                                           "N_states", "N_days", "h", "I_states"),  
                                               parameters.to.save = c("theta", "Sigma", 
                                                                      "p","sigma2_y", "sigma2_0"),
                                               n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                               model.file = model_file)
  
  saveRDS(presidential_model_gamma_2_0.5_prior, file = "gamma_2_0.5.Rds")
}
```

```{r final presidential model electoral votes function}
iterations = presidential_model_gamma_2_0.5_prior$BUGSoutput$n.keep * presidential_model_gamma_2_0.5_prior$BUGSoutput$n.chains 

electoral_data <- read.csv("Electoral_College.csv") %>%
  filter(Year == 2020)

electoral_data$states <- c("AL", "AK","AZ","AR","CA","CO","CT","DC",
                           "DE","FL","GA","HI","ID","IL","IN","IA","KS",
                           "KY","LA","ME","MD","MA","MI","MN","MS","MO","MT",
                           "NE","NV","NH","NJ","NM","NY","NC","ND","OH","OK",
                           "OR","PA","RI","SC","SD","TN","TX","UT","VT","VA","WA","WV","WI","WY")

#returns number of electoral votes biden wins for each iteration of the sampler
#we need to add to this the votes that he is guaranteed from other states

prediction_per_simulation <- function(model_output, i){
  elec_sims <- model_output$BUGSoutput$sims.list$theta[i,,1]
  vote_share_by_state <- data.frame(states, elec_sims)
  
  
  results <- merge(vote_share_by_state, electoral_data, by = "states") %>%
    dplyr::select(-c(Year)) 
  biden_wins <- results %>%
    filter(elec_sims > 50) 
  biden_electoral_votes <- sum(biden_wins$Votes)
  
  #add in the number of guaranteed votes from other states!
  biden_votes = votes_going_to_biden + biden_electoral_votes
  return(biden_votes)
}
```


```{r eval=FALSE}
i = 1
model_output = presidential_model_gamma_2_0.5_prior
yes = list()
for (k in 1:2000) {
  elec_sims <- model_output$BUGSoutput$sims.list$theta[k,,1]
  vote_for_biden = list()
  for (i in 1:length(elec_sims)) {
    list = c()
    for (j  in  1:100) {
      list[j] <- rbinom(100, 1, elec_sims[i]/100) %>% mean()
    }
    vote_for_biden[[i]] <- list
  }
  yes[[k]] <- vote_for_biden
  
  if (k %% 50 == 0) {
    print(k)
  }
}
yes %>% unlist() %>% sd()
```


```{r final presidential model electoral votes histogram}
final_results_presidential <- c()

for (i in 1:iterations){
  final_results_presidential[i] = prediction_per_simulation(presidential_model_gamma_2_0.5_prior, i)
}


#hist(final_results, main = "Presidential Election: Predicted Number of Electoral Votes to Biden", xlab = "Count")

prob_of_biden_winning <- mean(final_results_presidential > 270) * 100
lower_q_prob_of_biden_winning  <- quantile(final_results_presidential > 270, probs = c(0.025))
upper_q_prob_of_biden_winning  <-  quantile(final_results_presidential > 270, probs = c(0.975))
mean_electoral <- mean(final_results_presidential)
lower_q_presidential_electoral_college <- quantile(final_results_presidential, probs = c(0.025))
upper_q_presidential_electoral_college <- quantile(final_results_presidential, probs = c(0.975))


ggplot(data = tibble(final_results_presidential),  aes(x = final_results_presidential)) + 
  geom_histogram(bins = 20) + 
  geom_vline(xintercept = mean_electoral, color = "blue") + 
  geom_vline(xintercept = c(lower_q_presidential_electoral_college,upper_q_presidential_electoral_college), color = "red", linetype = 2) + 
  labs(title = "Predicted Number of Biden's Electoral Votes",
       subtitle = paste0("Predicted Probability of Biden Winning: ", prob_of_biden_winning, "%"),
       x = "Number of Biden's Electoral Votes",
       y = "Count")
```

```{r Probability of Democratic Victory in each Swing State, cache=TRUE}
predictions_per_state_presidential <- function(model_output, state){
  win_dem <- c()
  for (i in 1:iterations){
    
    elec_sims <- model_output$BUGSoutput$sims.list$theta[i,,1]
    vote_share_for_state <- data.frame(states, elec_sims) %>%
      filter(states == state)
    vote_share_val <- vote_share_for_state$elec_sims
    if (vote_share_val > 50){
      win_dem[i] <- 1
    }
    if (vote_share_val < 50){
      win_dem[i] <- 0
    }
  }
  probability_voting_dem <- round(100*sum(win_dem)/iterations, 3)
  return(probability_voting_dem)
}

probs_voting_dem <- c()
i = 1
for (state in states){
  prob_voting_dem <- predictions_per_state_presidential(presidential_model_gamma_2_0.5_prior, state)
  probs_voting_dem[i] <- prob_voting_dem
  i = i + 1
}

prob_voting_dem_table <- data.frame(states, probs_voting_dem) %>%
  mutate(State = states) %>%
  mutate(Probability = probs_voting_dem/100) %>%
  select(State, Probability)
kable(prob_voting_dem_table, caption = "Presidential Election: Probability of Democratic Victory in each Swing State")

```

```{r Predicted Democratic Vote Share in each Swing State}
mean_vote_share <- presidential_model_gamma_2_0.5_prior$BUGSoutput$sims.list$theta[,,1] %>% colMeans()
lower_q_presidential <- presidential_model_gamma_2_0.5_prior$BUGSoutput$sims.list$theta[,,1] %>%  matrixStats::colQuantiles(probs = c(0.025))
upper_q_presidential <- presidential_model_gamma_2_0.5_prior$BUGSoutput$sims.list$theta[,,1] %>%  matrixStats::colQuantiles(probs = c(0.975))

vote_share_by_state <- data.frame(states, lower_q_presidential, mean_vote_share, upper_q_presidential) %>%
  mutate(State = states) %>%
  mutate(`2.5%` = round(lower_q_presidential, 1)) %>%
  mutate(`97.5%` = round(upper_q_presidential, 1)) %>%
  mutate(Mean = round(mean_vote_share, 1)) %>%
  select(State, `2.5%`, Mean, `97.5%`)
kable(vote_share_by_state, caption = "Presidential Elections: Predicted Democratic Vote Share in each Swing State")
```

```{r}

ggplot() + 
  geom_density(aes(x = presidential_model_gamma_2_0.5_prior$BUGSoutput$sims.list$theta[,1,1])) + 
  geom_vline(xintercept = theta_1_1_mean)

# tidybayes::gather_draws(presidential_model_gamma_2_0.5_prior %>% as.mcmc() %>% mcmc.list() , theta[i, j]) %>% 
#   filter(i == 1 & j == 1) %>% 
#   mutate(param = ifelse(is.na(i), .variable, paste0(.variable,"[", i,", ", j, "]"))) %>%
#   ggplot(aes(x = .iteration, y = .value, color = as.factor(.chain))) + 
#   geom_line(alpha = 0.6) +  
#   facet_grid(param~., scales = "free_y")
```

```{r presidential model sensitivity 1}
gamma_4_1_prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  nu_beta ~ dunif(0,100)
  tau_beta ~ dunif(0,100)
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(4, 1)
  "

model_file <- generate_presidential_model_text(gamma_4_1_prior)
if (file.exists("gamma_4_1.Rds")) {
  presidential_model_gamma_4_1_prior <- readRDS("gamma_4_1.Rds")
} else {
  presidential_model_gamma_4_1_prior <- jags(data = list("y","t", "r", "N_polls", 
                                                         "N_states", "N_days", "h", "I_states"),  
                                             parameters.to.save = c("theta", "Sigma", 
                                                                    "p","sigma2_y", "sigma2_0"),
                                             n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                             model.file = model_file)
  
  saveRDS(presidential_model_gamma_4_1_prior, file = "gamma_4_1.Rds")
}
```

```{r}
# final_results <- c()
# 
# for (i in 1:iterations){
#   final_results[i] = prediction_per_simulation(presidential_model_gamma_4_1_prior, i)
# }
# 
# hist(final_results)
# mean(final_results >= 270)
# 
# ggplot() + 
#   geom_density(aes(x = presidential_model_gamma_4_1_prior$BUGSoutput$sims.list$theta[,1,1])) + 
#   geom_vline(xintercept = theta_1_1_mean)
# 
# tidybayes::gather_draws(presidential_model_gamma_4_1_prior %>% coda::as.mcmc(), theta[i, j]) %>% 
#   filter(i == 1 & j == 1) %>% 
#   mutate(param = ifelse(is.na(i), .variable, paste0(.variable,"[", i,", ", j, "]"))) %>%
#   ggplot(aes(x = .iteration, y = .value, color = as.factor(.chain))) + 
#   geom_line(alpha = 0.6) +  
#   facet_grid(param~., scales = "free_y")

```

```{r presidential model sensitivity 2}
exp_0.25_prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  nu_beta ~ dunif(0,100)
  tau_beta ~ dunif(0,100)
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dexp(0.25)
  "

model_file <- generate_presidential_model_text(exp_0.25_prior)
if (file.exists("exp_0_25.Rds")) {
  presidential_model_exp_0.25_prior <- readRDS("exp_0_25.Rds")
} else {
  presidential_model_exp_0.25_prior <- jags(data = list("y","t", "r", "N_polls", 
                                                        "N_states", "N_days", "h", "I_states"),  
                                            parameters.to.save = c("theta", "Sigma", 
                                                                   "p","sigma2_y", "sigma2_0"),
                                            n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                            model.file = model_file)
  
  saveRDS(presidential_model_exp_0.25_prior, file = "exp_0_25.Rds")
}
```

```{r}
# final_results <- c()
# 
# for (i in 1:iterations){
#   final_results[i] = prediction_per_simulation(presidential_model_exp_0.25_prior, i)
# }
# 
# hist(final_results)
# mean(final_results >= 270)
# 
# 
# ggplot() + 
#   geom_density(aes(x = presidential_model_exp_0.25_prior$BUGSoutput$sims.list$theta[,1,1])) + 
#   geom_vline(xintercept = theta_1_1_mean)

# tidybayes::gather_draws(presidential_model_exp_0.25_prior %>% coda::as.mcmc(), theta[i, j]) %>% 
#   filter(i == 1 & j == 1) %>% 
#   mutate(param = ifelse(is.na(i), .variable, paste0(.variable,"[", i,", ", j, "]"))) %>%
#   ggplot(aes(x = .iteration, y = .value, color = as.factor(.chain))) + 
#   geom_line(alpha = 0.6) +  
#   facet_grid(param~., scales = "free_y")

```

```{r presidential model sensitivity 3}
gamma_1_0.25_prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  nu_beta ~ dunif(0,100)
  tau_beta ~ dunif(0,100)
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(1, 0.25)
  "

model_file <- generate_presidential_model_text(gamma_1_0.25_prior)
if (file.exists("gamma_1_025.Rds")) {
  presidential_model_gamma_1_0.25_prior <- readRDS("gamma_1_025.Rds")
} else {
  presidential_model_gamma_1_0.25_prior <- jags(data = list("y","t", "r", "N_polls", 
                                                            "N_states", "N_days", "h", "I_states"),  
                                                parameters.to.save = c("theta", "Sigma", 
                                                                       "p","sigma2_y", "sigma2_0"),
                                                n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                                model.file = model_file)
  
  saveRDS(presidential_model_gamma_1_0.25_prior, file = "gamma_1_025.Rds")
}
```

```{r}
# final_results <- c()
# 
# for (i in 1:iterations){
#   final_results[i] = prediction_per_simulation(presidential_model_gamma_1_0.25_prior, i)
# }
# 
# hist(final_results)
# mean(final_results >= 270)
# 
# 
# ggplot() + 
#   geom_density(aes(x = presidential_model_gamma_1_0.25_prior$BUGSoutput$sims.list$theta[,1,1])) + 
#   geom_vline(xintercept = theta_1_1_mean)

# tidybayes::gather_draws(presidential_model_gamma_1_0.25_prior %>% coda::as.mcmc(), theta[i, j]) %>% 
#   filter(i == 1 & j == 1) %>% 
#   mutate(param = ifelse(is.na(i), .variable, paste0(.variable,"[", i,", ", j, "]"))) %>%
#   ggplot(aes(x = .iteration, y = .value, color = as.factor(.chain))) + 
#   geom_line(alpha = 0.6) +  
#   facet_grid(param~., scales = "free_y")
```

```{r presidential model sensitivity plots, cache=TRUE}
sen_analysis_priors_names <- c("Ga(2, 0.5))",
                               "Ga(4, 1)",
                               "Ga(1, 0.25)",
                               "Exp(1/4)")   
sen_analysis_priors <- list(presidential_model_gamma_2_0.5_prior,
                            presidential_model_gamma_4_1_prior,
                            presidential_model_exp_0.25_prior,
                            presidential_model_gamma_1_0.25_prior)     

sen_tbl_list <- list()
for (i in 1:4) {
  sen_tbl_list[[i]] <- tidybayes::gather_draws(sen_analysis_priors[[i]] %>% coda::as.mcmc(), theta[i, j]) %>% 
    filter(i == 5 & j == 1)
}

theta_1_1_mean <- presidential_model_gamma_2_0.5_prior$BUGSoutput$sims.list$theta[,5,1] %>% mean()

sensitivity_plot_presidential <- do.call(bind_rows, sen_tbl_list) %>% 
  dplyr::mutate(model = rep(sen_analysis_priors_names, each=2000),
                model = factor(model,
                               levels = sen_analysis_priors_names,
                               labels = c(expression(paste(sigma[0]^2, " ~ Ga(2, 0.5)")),
                                          expression(paste(sigma[0]^2, " ~ Ga(4, 1)")),
                                          expression(paste(sigma[0]^2, " ~ Ga(1, 0.25)")),
                                          expression(paste(sigma[0]^2, " ~ Exp(0.25)"))))) %>% 
  #mutate(param = ifelse(is.na(i), .variable, paste0(.variable,"[", i,", ", j, "]"))) %>%
  ggplot() + 
  geom_density(aes(x = .value)) + 
  geom_vline(xintercept = theta_1_1_mean) +  
  facet_wrap(model~., scales = "free_y", labeller = "label_parsed")
```

# Introduction

The 2020 U.S. elections, coupled with the unique social and economic turmoil corroborated by COVID-19, is documented to have globally political implications [[1]][Bibliography],[[2]][Bibliography]. Predicting the results of these elections is of critical interest to small businesses, health professionals, racial minorities, and many others. In this case study, we seek to predict the results of the US presidential, senate-majority, electoral college, NC congressional, and NC senate election outcomes. Our specific research objectives include the following:

1. Predict the outcome of the presidential election as well as the electoral college vote
2. Predict whether the US Senate remains in Republican control, and the outcome of the North Carolina senate election
3. Predict the outcomes of all North Carolina Congressional elections (the 13 federal Representatives to Congress)

We seek to provide not only predictions of winners and estimated vote shares, but also meaningful quantifications of uncertainty surrounding estimates. In order to model presidential and senate outcomes, we will be utilizing publicly available polling data with an extension of the Linzer model, which takes a dynamic Bayesian approach to forecasting election results. To predict the outcomes of all North Carolina Congressional elections, we will first explore voting patterns of different demographics within the state to determine who is likely to vote, and then build on these results by predicting *how* these individuals will vote in the 13 Congressional elections. In doing so, we hope to offer insight to campaign managers and activist groups so they may better understand likelihood and access to voting.

# Presidential Election

## Data


## Methods

We employ a dynamic Bayesian approach to forecast presidential election outcomes, similar to that in Linzer [[3]][Bibliography]. Our motivation in selecting this model stems from its ability to compound polling data *over time* (i.e., rather than using a naive model that is heavily influenced by an inaccurate poll, we account for several polls with evolving preferences). Instead of basing our priors on vote shares that are centered about 50, like in Linzer [[3]][Bibliography], we innovate the approach by relying more heavily on 2016 election vote shares, suggesting that those voters vote similarly in this election [[5]][Bibliography]. With this data, we predict the outcomes of 15 swing states: Arizona, Colorado, Florida, Georgia, Iowa, Maine, Michigan, Minnesota, New Hampshire, Nevada, North Carolina, Ohio, Pennsylvania, Texas, and Wisconsin [[4]][Bibliography], with a hierarchical prior on our model parameters. Further, our final model estimates the correlation IS IT CORRELATION OR COVARIANCE ASLKDFGHALSKFHAKFH structure between states, so more similar states pull information from one another.

$$
\begin{aligned}
Y_{k} \sim  N(\theta_{i[k]t[k]},\sigma^2_{yi}) \\ 
\theta_{i 1} \sim N(h_i, \sigma^2_0) , \ \mathbf{\theta_{\mathbf{ \cdot} t}} \sim MVN&(\mathbf{\theta_{\mathbf{\cdot} t-1}},\mathbf{\Sigma}) \\ 
\mathbf{\Sigma}^{-1} \sim Wish(\mathbf{I_{15}}, 16&) &  (1) \\
\frac{1}{\sigma^2_{yi}} \sim Ga(\nu_y,\nu_y*\tau_y) , \ \frac{1}{\sigma^2_{0}} \sim & \ Ga(2, 0.5)\\
\nu_y \sim Unif(0,100), \ \tau_y \sim Un&if(0,100)\\
\end{aligned}
$$

Let $Y_k$, Biden's share of the two-party vote from each poll $k$, be normally distributed with mean $\theta_{i[k]t[k]}$, where poll $k$ ended $t$ days before the election and was conducted in swing state $i \in (1 \dots 15)$. Each state has its own observation variance, $\sigma^2_{yi}$ - the indice $y$ indicates that it is the observation variance from each state. We set a Gamma prior on $\frac{1}{\sigma^2_{yi}}\sim Ga(\nu_y,\nu_y*\tau_y)$, where both $\nu_y, \tau_y \sim Unif(0,100)$. We set normal priors on $\boldsymbol{\theta}_{\boldsymbol{ \cdot}  1}$, centered on $h_i$, Hilary Clinton’s 2016 vote share from swing state $i$, with variance $\sigma^2_0$. While the Linzer model incorrectly predicted the results of the 2016 presidential election due to polling information inaccuracies, we hope to balance this reliance on the polling information by adjusting our priors to rely more heavily on the 2016 election [5]. Since we also estimate the correlation structure between states, we let $\boldsymbol{\theta}_{\boldsymbol{ \cdot} t} \sim MVN(\boldsymbol{\theta}_{\boldsymbol{\cdot} t-1},\mathbf{\Sigma})$, where $\mathbf{\Sigma}^{-1} \sim Wish(\mathbf{I_{15}}, 16)$.

Using JAGS, we ran Model 1 with 2 chains, each with 75,000 simulations, 25,000 burn-in, and thinned the sampler by keeping every 50th sample. This left us with 2,000 samples. Then, for each sample, we performed the following:

1. Extract the 15 values of  $\theta_{\cdot 1}$, Biden’s estimated vote share on the day of the election from each swing state $i \in (1 \dots 15)$.

2. For each $\theta_{i 1}$ value, if it is greater than 50%, record the number of electoral votes from swing state $i$.

Based on [SOURCE], Biden is expected to safely win 200 electoral votes from __ states. The sum of the 200 expected electoral votes with the predicted electoral votes from the 15 swing states indicates the total number of estimated electoral votes he would win. If the number of estimated electoral votes is greater than 270, we predict that Biden wins the electoral college vote. Thus, from this model, we are able to predict the electoral college vote and the outcome of the presidential election.

## Results

Our model predicts that Biden will win `r mean_electoral` (`r lower_q_presidential_electoral_college`, `r upper_q_presidential_electoral_college`) electoral college votes. Additionally, the model estimates that in `r round(prob_of_biden_winning*100, 4)`% of our samples, Biden is predicted to have over 270 electoral votes. Thus, we predict Biden will win with probability `r round(prob_of_biden_winning*100)`. 

### Model Diagnostics

Traceplots for select parameters and quantiles for values can be found in the Appendix. To determine if our model has converged sufficiently, we first examine traceplots for each of the parameters. Traceplots with random scatter around a mean value indicates that the model has converged. RHAT values provide an estimate of convergence based on the variance of an estimated parameter between chains, and the variance within a chain. The closer the RHAT value to 1, the better the model has converged. The traceplots show the chains have mixed well and RHAT values close to 1, indicating that our model has sufficiently converged. 

### Sensitivity Analysis

```{r}
sensitivity_plot_presidential
``` 

In Figure XXXX,  We explore the posterior distributions of  $\theta_{1 1}$  and $\theta_{51}$, which are the posterior parameters that indicate Biden’s predicted two-party vote share on the day of the election in North Carolina  and Pennsylvania, resulting from various priors. The red lines indicate our posterior mean estimate from our final model. The posterior distributions are roughly the same for the four different priors on  $\frac{1}{\sigma^2_0}$. Thus, we can verify our results are not as sensitive to prior choice [[6]][Bibliography].


### External Validation

We perform validation on this model by predicting the winner of the 2012 presidential election and the electoral college vote. In this model, we predict the outcomes from 9 swing states [ https://www.politico.com/2012-election/swing-state/,  maybe list the swing states] We used the same priors from the previous presidential model, with the exception of the normal priors on $\theta_{\cdot 1}$. This time, we centered on President Obama’s  2008  vote share from swing state $i in (1 \dots 9)$.  

We applied the same prediction method to estimate the election outcome and the electoral college vote from 2012. Based on https://www.politico.com/2012-election/swing-state/, Obama  gained 237 electoral votes from ____ states. This was  summed up with the total number of electoral votes he was predicted to win from  the 9 swing states.  Similarly, if Obama gained more than 270 electoral votes, that meant that the model predicts he would win the 2012 election (which he did :)). 


## Predicting 2012 Elections Using this Model 

```{r}
# https://www.politico.com/2012-election/swing-state/  used to determine swing states 
polls2012 <- read_csv("all_polls_2012.csv") 

polls2012 <- polls2012 %>% 
  filter(population %in% c("Registered Voters", "Likely Voters")) %>% 
  mutate(state = ifelse(state == "--","US",state)) %>%
  mutate(pct = obama / (obama + romney) *100) %>% 
  mutate(start.date = mdy(start.date),
         end.date = mdy(end.date),
         election_date = "2012-11-06" %>% as.Date(),
         days_to_election = election_date - end.date) %>%
  filter(state %in% c("CO", "FL", "IA", "NV", "NH", "NC", "OH", "VA", "WI"))
```

```{r}
obama_votes <- 237
states_2012 <- polls2012$state %>% unique
y_2012 <- polls2012$pct
r_2012 <- match(polls2012$state,states_2012)
t_2012 <- polls2012$days_to_election + 1 
N_polls_2012 <- y_2012 %>% length
N_states_2012 <- states_2012 %>% length
N_days_2012 <- t_2012 %>% max
I_states_2012 <- diag(N_states_2012)
```

```{r}
# obama's vote share in 2008: https://www.nytimes.com/elections/2008/results/president/votes.html
vote_share_2008 <- data.frame(polls2012$state) 
vote_share_2008 <- distinct(vote_share_2008) %>%
  mutate(obama_percent = case_when(
    polls2012.state == "CO" ~ 54/(54 + 45),
    polls2012.state == "FL" ~ 51/(51 + 48),
    polls2012.state == "IA" ~ 54/(54 + 45),
    polls2012.state == "NV" ~ 55/(55 + 43),
    polls2012.state == "NH" ~ 54/(54 + 45),
    polls2012.state == "NC" ~ 50/(50 + 50),
    polls2012.state == "OH" ~ 51/(51 + 47),
    polls2012.state == "VA" ~ 53/(53 + 46),
    polls2012.state == "WI" ~ 56/(56 + 42)
    
  )) %>%
  mutate(obama_percent = 100*obama_percent)
obama2008 <- vote_share_2008$obama_percent
```

```{r}
# final model 
gamma_2_0.5_prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(2,0.5)
  "

model_file <- generate_presidential_model_text(gamma_2_0.5_prior)
if (file.exists("gamma_2_0.5_2012.Rds")) {
  presidential2012_model_gamma_2_0.5_prior <- readRDS("gamma_2_0.5_2012.Rds")
} else {
  presidential2012_model_gamma_2_0.5_prior <- jags(data = list(y=y_2012,t=t_2012, r=r_2012, N_polls=N_polls_2012, 
                                                               N_states=N_states_2012, N_days=N_days_2012, h=obama2008, I_states=I_states_2012),  
                                                   parameters.to.save = c("theta", "Sigma", 
                                                                          "p","sigma2_y", "sigma2_0"),
                                                   n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                                   model.file = model_file)
  
  saveRDS(presidential2012_model_gamma_2_0.5_prior, file = "gamma_2_0.5_2012.Rds")
}
```

```{r}
iterations = presidential2012_model_gamma_2_0.5_prior$BUGSoutput$n.keep * presidential2012_model_gamma_2_0.5_prior$BUGSoutput$n.chains 

electoral_data <- read.csv("Electoral_College.csv") %>%
  filter(Year == 2012)

electoral_data$states_2012 <- c("AL", "AK","AZ","AR","CA","CO","CT","DC",
                                "DE","FL","GA","HI","ID","IL","IN","IA","KS",
                                "KY","LA","ME","MD","MA","MI","MN","MS","MO","MT",
                                "NE","NV","NH","NJ","NM","NY","NC","ND","OH","OK",
                                "OR","PA","RI","SC","SD","TN","TX","UT","VT","VA","WA","WV","WI","WY")

#returns number of electoral votes biden wins for each iteration of the sampler
#we need to add to this the votes that he is guaranteed from other states

prediction_per_simulation <- function(model_output, i){
  elec_sims <- presidential2012_model_gamma_2_0.5_prior$BUGSoutput$sims.list$theta[i,,1]
  vote_share_by_state <- data.frame(states_2012, elec_sims)
  
  
  results <- merge(vote_share_by_state, electoral_data, by = "states_2012") %>%
    dplyr::select(-c(Year)) 
  obama_wins <- results %>%
    filter(elec_sims > 50) 
  obama_electoral_votes <- sum(obama_wins$Votes)
  
  #add in the number of guaranteed votes from other states!
  biden_votes = obama_votes + obama_electoral_votes
  return(biden_votes)
}

final_results2012 <- c()

for (i in 1:iterations){
  final_results2012[i] = prediction_per_simulation(presidential2012_model_gamma_2_0.5_prior, i)
}

hist(final_results2012)
mean(final_results2012 >=1)
mean(final_results2012)

final_results2012 %>% quantile()
```


```{r}
knitr::opts_chunk$set(eval = FALSE,
                      message = FALSE,
                      warning = FALSE)
```
# US Senate Election

```{r Read in Data}
#Filter to see if any non democratic or republican candidates are polling high
# add New Mexico  and Missisipi 
`%notin%` <- Negate(`%in%`)
senate_polls <- read_csv("senate_polls.csv")
senate_polls$state %>% unique
senate_polls %>%
  filter(cycle == "2020") %>%
  filter(candidate_party %notin% c("DEM", "REP")) %>%
  arrange(desc(pct)) %>%
  select(poll_id, state, candidate_name, candidate_party, pct)

#TOP THREE: DUNBAR, HARRINGTON, WILSON
#Dunbar (AK) is a democrat, but running as an independent against republican and democratic candidates- but as of more recent polls he isn't relevant
#Harrington (AR) is liberatrian running against a republican
#Wilson (IL) is an independent running against a democrat- he can be counted as a democrat 

#filter out AR because there is a 0% chance a democrat wins here
#filter out IL because there is a 100% chance a democrat wins here
#remember to add back in one senator for IL because that's sort of a given!
```

```{r}
senate_polls_cleaned <- senate_polls %>%
  filter(cycle == "2020") %>%
  filter(population %in% c("lv","rv")) %>% 
  filter(office_type == "U.S. Senate") %>%
  
  #add separate elections for georgia and arizona special
  mutate(state = case_when(
    state == "Georgia" & seat_name == "Class III" ~ "Georgia*",
    state == "Arizona" & seat_name == "Class III" ~ "Arizona*",
    TRUE ~ as.character(state)
  )) %>%
  
  #get rid of arkansas because there is no chance that a democrat will win here 
  #get rid of illionis because basically guarantted a democrat wins
  filter(state %notin% c("Arkansas", "Illinois")) %>%
  filter(candidate_party %in% c("DEM", "REP")) %>%
  filter(poll_id != 58956 & question_id != 100828) %>%
  filter(poll_id != 67060 & question_id != 125304) #get rid of weird polls
#senate_polls_cleaned$state %>% unique
```


```{r}
democratic_candidates <- senate_polls_cleaned %>%
  dplyr::filter(candidate_party == "DEM") %>%
  dplyr::group_by(question_id, poll_id, state, race_id, pollster, start_date, end_date) %>%
  dplyr::summarize(total_dems_pct = sum(pct)) 
#democratic_candidates 
```

```{r}
republican_candidates <- senate_polls_cleaned %>%
  dplyr::filter(candidate_party == "REP") %>%
  dplyr::group_by(question_id, poll_id, state, race_id, pollster, start_date, end_date) %>%
  dplyr::summarize(total_rep_pct = sum(pct)) 
#republican_candidates
```

```{r}
senate_data <- merge(democratic_candidates, republican_candidates, by = c("state", "question_id", "poll_id", "race_id", "pollster", "start_date", "end_date"))
senate_data <- senate_data %>%
  mutate(pct_dem = 100*total_dems_pct/(total_dems_pct + total_rep_pct))
#senate_data
```

```{r}
senate <- senate_data %>%
  mutate(start_date = mdy(start_date),
         end_date = mdy(end_date),
         election_date = "2020-11-03" %>% as.Date(),
         days_to_election = election_date - end_date,
         y = pct_dem) %>%
  dplyr::filter(days_to_election <= 100) %>%
  filter(state %in% c("Alaska", "Alabama", "Arizona*", "Colorado", "Georgia*", "Georgia", "Iowa", "Kansas", "Kentucky",
                      "Maine", "Michigan", "Minnesota", "Mississippi",
                      "Montana", #"New Hampshire",
                      "New Mexico",
                      "North Carolina", "South Carolina", "Texas")) #THIS is 538 (Kentucky+NH are  kinda red and kinda blue)

# filter(state %in% c("Alabama", "Arizona*", "Colorado", "Georgia*", "Georgia", "Iowa", "Kansas", "Kentucky",
#                     "Maine", "Michigan", "Minnesota", 
#                     "Montana", "New Hampshire",
#                     
#                     "North Carolina", "South Carolina", "Texas")) #  THIS is ballotpedia states
```


```{r senate jags data}
states_senate <- senate$state %>% unique
y_senate <- senate$y
r_senate <- match(senate$state,states_senate)
t_senate <- senate$days_to_election + 1 
N_polls_senate <- y_senate %>% length
N_states_senate <- states_senate %>% length
N_days_senate <- t_senate %>% max
I_states_senate <- diag(N_states_senate)
jags_data_senate <- list(y=y_senate,t=t_senate,r=r_senate,
                         N_polls=N_polls_senate,N_states=N_states_senate,N_days=N_days_senate, I_states=I_states_senate)
```

```{r}
generate_senate_model_text = function(hierarchical_priors_senate) {
  model_file <- tempfile()
  likelihood_base_priors = "
  for(k in 1:N_polls){
    y[k] ~ dnorm(p[k],1/sigma2_y[r[k]]) #note no longer binomial
    p[k] = theta[r[k],t[k]] 
  }
  for(j in 2:N_days){
    theta[1:N_states,j] ~ dmnorm(theta[1:N_states,j-1],Phi)
  }
  
  Phi ~ dwish(I_states,N_states+1) 
  Sigma = inverse(Phi)
  #hierarchical component
  for(j in 1:N_states){
    sigma2_y[j] = 1/sigma2_y_inv[j]
    sigma2_y_inv[j] ~ dgamma(nu_y,nu_y*tau_y) 
    
    theta[j,1] ~ dnorm(mu0, sigma2_0)
  }
  "
  
  model_text <- paste("model{ ", likelihood_base_priors, hierarchical_priors_senate,"}")
  writeLines(model_text,con=model_file)
  return(model_file)
}
```

```{r}
senate_gamma_2_1_mu_7.5.prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  mu0 ~ dnorm(50, pow(7.5,-1)) 
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(2,1) 
  "

model_file_senate_gamma_2_1_mu_7.5.prior <- generate_senate_model_text(senate_gamma_2_1_mu_7.5.prior) 
if (file.exists("senate_gamma_2_1_mu_7.5.prior.Rds")) { 
  senate_gamma_2_1_mu_7.5.prior_model <- readRDS("senate_gamma_2_1_mu_7.5.prior.Rds") 
} else {
  senate_gamma_2_1_mu_7.5.prior_model <- jags(data = jags_data_senate,  
                                              parameters.to.save = c("theta", "Sigma", 
                                                                     "p","sigma2_y", "sigma2_0"),
                                              n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                              model.file = model_file_senate_gamma_2_1_mu_7.5.prior)
  
  saveRDS(senate_gamma_2_1_mu_7.5.prior_model, file = "senate_gamma_2_1_mu_7.5.prior.Rds")
}

n_iter <- dim(senate_gamma_2_1_mu_7.5.prior_model$BUGSoutput$sims.list$theta[,,1])[1]

prediction_per_simulation_senate <- function(model_output, i){
  elec_sims <- model_output$BUGSoutput$sims.list$theta[i,,1]
  vote_share_by_state <- data.frame(states_senate, elec_sims)
  
  dem_states_df <- vote_share_by_state %>%
    filter(elec_sims > 50)
  dem_states <- dem_states_df$states_senate
  num_dem_states <- length(dem_states)
  return(num_dem_states)
}

final_results_senate <- c()

for (i in 1:n_iter){
  final_results_senate[i] = prediction_per_simulation_senate(senate_gamma_2_1_mu_7.5.prior_model, i)
}

mean(final_results_senate >= 9)
mean(final_results_senate)
final_results_senate %>% hist()

tidybayes::gather_draws(senate_gamma_2_1_mu_7.5.prior_model %>% as.mcmc() %>% mcmc.list() , theta[i, j]) %>%
  filter(i == 1 & j == 1) %>%
  mutate(param = ifelse(is.na(i), .variable, paste0(.variable,"[", i,", ", j, "]"))) %>%
  ggplot(aes(x = .iteration, y = .value, color = as.factor(.chain))) +
  geom_line(alpha = 0.6) +
  facet_grid(param~., scales = "free_y")
```

```{r}
senate_gamma_5_2_mu_7.5.prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  mu0 ~ dnorm(50, pow(7.5,-1)) 
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(5,2) 
  "

model_file_senate_gamma_5_2_mu_7.5.prior <- generate_senate_model_text(senate_gamma_5_2_mu_7.5.prior) 
if (file.exists("senate_gamma_5_2_mu_7.5.prior.Rds")) { 
  senate_gamma_5_2_mu_7.5.prior_model <- readRDS("senate_gamma_5_2_mu_7.5.prior.Rds") 
} else {
  senate_gamma_5_2_mu_7.5.prior_model <- jags(data = jags_data_senate,  
                                              parameters.to.save = c("theta", "Sigma", 
                                                                     "p","sigma2_y", "sigma2_0"),
                                              n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                              model.file = model_file_senate_gamma_5_2_mu_7.5.prior)
  
  saveRDS(senate_gamma_5_2_mu_7.5.prior_model, file = "senate_gamma_5_2_mu_7.5.prior.Rds")
}

final_results_senate <- c()

for (i in 1:n_iter){
  final_results_senate[i] = prediction_per_simulation_senate(senate_gamma_5_2_mu_7.5.prior_model, i)
}

mean(final_results_senate >= 9)
mean(final_results_senate)
final_results_senate %>% hist()

tidybayes::gather_draws(senate_gamma_5_2_mu_7.5.prior_model %>% as.mcmc() %>% mcmc.list() , theta[i, j]) %>%
  filter(i == 1 & j == 1) %>%
  mutate(param = ifelse(is.na(i), .variable, paste0(.variable,"[", i,", ", j, "]"))) %>%
  ggplot(aes(x = .iteration, y = .value, color = as.factor(.chain))) +
  geom_line(alpha = 0.6) +
  facet_grid(param~., scales = "free_y")
```


```{r}
senate_gamma_2_2_mu_10.prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  mu0 ~ dnorm(50, pow(10,-1)) 
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(0.5,0.5) 
  "

model_file_senate_gamma_2_2_mu_10.prior <- generate_senate_model_text(senate_gamma_2_2_mu_10.prior) 
if (file.exists("senate_gamma_2_2_mu_10.prior.Rds")) { 
  senate_gamma_2_2_mu_10.prior_model <- readRDS("senate_gamma_2_2_mu_10.prior.Rds") 
} else {
  senate_gamma_2_2_mu_10.prior_model <- jags(data = jags_data_senate,  
                                             parameters.to.save = c("theta", "Sigma", 
                                                                    "p","sigma2_y", "sigma2_0"),
                                             n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                             model.file = model_file_senate_gamma_2_2_mu_10.prior)
  
  saveRDS(senate_gamma_2_2_mu_10.prior_model, file = "senate_gamma_2_2_mu_10.prior.Rds")
}

final_results_senate <- c()

for (i in 1:n_iter){
  final_results_senate[i] = prediction_per_simulation_senate(senate_gamma_2_2_mu_10.prior_model, i)
}

mean(final_results_senate >= 9)
mean(final_results_senate)
final_results_senate %>% hist()

tidybayes::gather_draws(senate_gamma_2_2_mu_10.prior_model %>% as.mcmc() %>% mcmc.list() , theta[i, j]) %>%
  filter(i == 1 & j == 1) %>%
  mutate(param = ifelse(is.na(i), .variable, paste0(.variable,"[", i,", ", j, "]"))) %>%
  ggplot(aes(x = .iteration, y = .value, color = as.factor(.chain))) +
  geom_line(alpha = 0.6) +
  facet_grid(param~., scales = "free_y")
```

```{r}
senate_gamma_0.5_0.5_mu_10.prior <- "
  nu_y ~ dunif(0,100)
  tau_y ~ dunif(0,100)
  
  mu0 ~ dnorm(50, pow(10,-1)) 
  
  sigma2_0 = 1/sigma2_0_inv
  sigma2_0_inv ~ dgamma(0.5,0.5) 
  "

model_file_senate_gamma_0.5_0.5_mu_10.prior <- generate_senate_model_text(senate_gamma_0.5_0.5_mu_10.prior) 
if (file.exists("senate_gamma_0.5_0.5_mu_10.prior.Rds")) { 
  senate_gamma_0.5_0.5_mu_10.prior_model <- readRDS("senate_gamma_0.5_0.5_mu_10.prior.Rds") 
} else {
  senate_gamma_0.5_0.5_mu_10.prior_model <- jags(data = jags_data_senate,  
                                                 parameters.to.save = c("theta", "Sigma", 
                                                                        "p","sigma2_y", "sigma2_0"),
                                                 n.iter = 75000, n.burnin = 25000, n.thin = 50, n.chains = 2,
                                                 model.file = model_file_senate_gamma_0.5_0.5_mu_10.prior)
  
  saveRDS(senate_gamma_0.5_0.5_mu_10.prior_model, file = "senate_gamma_0.5_0.5_mu_10.prior.Rds")
}

final_results_senate <- c()

for (i in 1:n_iter){
  final_results_senate[i] = prediction_per_simulation_senate(senate_gamma_0.5_0.5_mu_10.prior_model, i)
}

mean(final_results_senate >= 9)
mean(final_results_senate)
final_results_senate %>% hist()
```


```{r cache=TRUE, include=FALSE}
senate_sen_analysis_priors_names <- c("Ga(2, 0.5))",
                                      "Ga(4, 1)",
                                      "Ga(1, 0.25)",
                                      "Exp(1/4)")   
senate_sen_analysis_priors <- list(senate_gamma_2_1_mu_7.5.prior_model,
                                   senate_gamma_5_2_mu_7.5.prior_model,
                                   senate_gamma_2_2_mu_10.prior_model,
                                   senate_gamma_0.5_0.5_mu_10.prior_model)     
senate_theta_1_1_mean <- senate_gamma_2_1_mu_7.5.prior_model$BUGSoutput$sims.list$theta[,5,1] %>% mean()
senate_sen_tbl_list <- list()
for (i in 1:4) {
  senate_sen_tbl_list[[i]] <- tidybayes::gather_draws(senate_sen_analysis_priors[[i]] %>% coda::as.mcmc(), theta[i, j]) %>% 
    filter(i == 1 & j == 1)
}
do.call(bind_rows, senate_sen_tbl_list) %>% 
  dplyr::mutate(model = rep(senate_sen_analysis_priors_names, each=2000),
                model = factor(model,
                               levels = senate_sen_analysis_priors_names,
                               labels = c(expression(paste(sigma[0]^2, " ~ Ga(2, 0.5)")),
                                          expression(paste(sigma[0]^2, " ~ Ga(4, 1)")),
                                          expression(paste(sigma[0]^2, " ~ Ga(1, 0.25)")),
                                          expression(paste(sigma[0]^2, " ~ Exp(0.25)"))))) %>% 
  #mutate(param = ifelse(is.na(i), .variable, paste0(.variable,"[", i,", ", j, "]"))) %>%
  ggplot() + 
  geom_density(aes(x = .value)) + 
  geom_vline(xintercept = senate_theta_1_1_mean) +  
  facet_wrap(model~., scales = "free_y", labeller = "label_parsed")
```

## Discussion

# Senate

## Data

## Methods

The Senate currently has 53 Republicans and 47 Democrats (including 2 Independents who caucus with the Democratic party). 35 seats are up in 2020 - thus, in order to reach 51 and “flip” the Senate, Democrats will need to win 16 of the 35 seats up for election. Of the 16 needed to flip the senate, several reputable sources confirm that the following8 states are very likely to vote for the Democratic candidate (Virginia, Oregon, Illinois, New Jersey, Delaware, Massachusetts, New Hampshire, and Rhode Island) and 9 states are very likely to vote Republican (Arkansas, Idaho, Louisiana, Nebraska, Oklahoma, Tennessee, South Dakota, West Virginia and Wyoming). However, 18 races in 17 states will be instrumental in determining if the senate flips: Alaska, Alabama, Arizona, Colorado, Georgia, Iowa, Kansas, Kentucky, Maine, Michigan, Minnesota, Mississippi, Montana, New Mexico, North Carolina, South Carolina, and Texas. (from 538). There are also two special elections: one in Arizona and one in Georgia (both of Georgia’s seats are up). [SOURCE for special election? or do we wanna say more about it] Of these 18 races, Democrats will need to win 8 in order to reach 16 seats and flip the senate. Thus, we are primarily interested in modelling the outcomes of only these “battleground” races. *mention somewhere that we are not using priors for vote shares, and this is because we don’t have a previous election that we can center our priors on. So, we stuck with 50*

This approach utilized polling data and a model similar to that of the presidential election [cite Linzer].  In this model, we predict the outcomes from 19 swing races. [4,SOURCE,  maybe list the swing states]We let these  races influence each other by placing a hierarchical prior on the model  parameters. Further, our final model estimates the correlation structure between races, so more similar races pull information from one another. 

[insert model latex]

Let $Y_k$, the Democratic candidate’s share of the two-party vote from each poll $k$, be normally distributed with mean $\theta_{i[k]t[k]}$, where poll $k$ ended $t$ days before the election and was conducted in battleground race $i \in (1 \dots 19)$. Each race has its own observation variance, $\sigma^2_{yi}$ - the indice $y$ indicates that it is the observation variance from each race We set a Gamma prior on $\frac{1}{\sigma^2_{yi}}\sim Ga(\nu_y,\nu_y*\tau_y)$, where both $\nu_y, \tau_y \sim Unif(0,100)$. We set normal priors on $\boldsymbol{\theta}_{\boldsymbol{ \cdot}  1}$, centered about 50 with variance $\sigma^2_0$. Since we also estimate the correlation structure between states, we let $\boldsymbol{\theta}_{\boldsymbol{ \cdot} t} \sim MVN(\boldsymbol{\theta}_{\boldsymbol{\cdot} t-1},\mathbf{\Sigma})$, where $\mathbf{\Sigma}^{-1} \sim Wish(\mathbf{I_{19}}, 20)$

Using JAGS, we ran Model 2 with 2 chains, each with 75,000 simulations, 25,000 burn-in, and thinned the sampler by keeping every 50th sample. This left us with 2,000 samples. Then, for each sample, we performed the following:
Extract the 19 values of  $\theta_{\cdot 1}$, the Democratic candidate’s estimated vote share on the day of the election from each battleground race $i \in (1 \dots 19)$.
For each $\theta_{i 1}$ value, if it is greater than 50%, that race is predicted to elect the Democratic candidate. 
Based on [SOURCE], 7 races are very likely to elect the Democratic candidate. We then add this to the number of predicted races that will elect a Democratic candidate. If the total number of races that predict a Democratic candidate being elected is at least  16, the Senate is then predicted to flip. 

Swing States Senate Election (from 538) : Alaska, Alabama, Arizona*, Colorado, Georgia*, Georgia, Iowa, Kansas, Maine, Michigan, Minnesota, Mississippi, Montana, New Mexico, North Carolina, South Carolina, Texas (17 states)

Out of the 18 remaining seats up for election: 
Solid Dem (>= 95): New  Hampshire, Virginia, Oregon, Illinois, New Jersey, DE, MA,  RI (8 states solid Dem)
Solid Rep (>= 95): Kentucky, Louisiana, WV, OK, ID,  SD, TN, NE, WY, AR (10 states solid Rep)
currently there are 47 dems (counting independents) and 53 republicans 
this means that, other than the 35 (23 Rep, 12 Dem) seats up, there are 35 democrats and 30 republicans in the senate
to flip, democrats need to get up to 51. They need 16 seats. 8 are “guarenteed”,  they need 8 from the swing states.  

# Results

### Model Diagnostics

### Sensitivity Analysis

### External Validation

## Discussion

## North Carolina Senate Election

# Congressional Elections

## Data

## Methods

## Results

### Model Diagnostics

### Sensitivity Analysis

### External Validation

## Discussion

# Conclusion

# Appendix A

# Appendix B

# Bibliography

1). “Braced for impact; America's presidential election." The Economist, 10 Oct. 2020, p. 66(US). Gale OneFile: CPI.Q, https://link.gale.com/apps/doc/A637802159/CPI?u=duke_perkins&sid=CPI&xid=e45fed0d. Accessed 28 Oct. 2020.
2). Martin, Susan F. “Commentary: The 2020 U.S. Presidential Election and Immigration.” International Migration, vol. 58, no. 5, 2020, pp. 274–276., doi:10.1111/imig.12772. 
3). Drew A. Linzer (2013) Dynamic Bayesian Forecasting of Presidential Elections in the States, Journal of the American Statistical Association, 108:501, 124-134, DOI: 10.1080/01621459.2012.737735
4). Linge, M. (2020, October 31). Inside the nine swing states the 2020 presidential election hinges on. Retrieved November 01, 2020, from https://nypost.com/2020/10/31/the-9-swing-states-the-2020-presidential-election-hinges-on/
5). Tamman, M., & Faulconbridge, G. (2016, November 09). How the polls, including ours, missed Trump's victory. Retrieved November 01, 2020, from https://www.reuters.com/article/us-usa-election-polls/how-the-polls-including-ours-missed-trumps-victory-idUSKBN1343O6
6). Hoff, P. D. (2010). Chapter 1: Introduction and examples. In A first course in bayesian statistical methods (pp. 5-7). Dordrecht: Springer.

>